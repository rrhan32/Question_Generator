(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactCoolForm = {}, global.React));
}(this, (function (exports, react) { 'use strict';

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  var has = Object.prototype.hasOwnProperty;

  function dequal(foo, bar) {
  	var ctor, len;
  	if (foo === bar) return true;

  	if (foo && bar && (ctor=foo.constructor) === bar.constructor) {
  		if (ctor === Date) return foo.getTime() === bar.getTime();
  		if (ctor === RegExp) return foo.toString() === bar.toString();

  		if (ctor === Array) {
  			if ((len=foo.length) === bar.length) {
  				while (len-- && dequal(foo[len], bar[len]));
  			}
  			return len === -1;
  		}

  		if (!ctor || typeof foo === 'object') {
  			len = 0;
  			for (ctor in foo) {
  				if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
  				if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
  			}
  			return Object.keys(bar).length === len;
  		}
  	}

  	return foo !== foo && bar !== bar;
  }

  var one;
  var all = {};
  var get$1 = function get(id) {
    return id ? all[id] : one;
  };
  var set$1 = function set(id, methods) {
    if (id) {
      all[id] = methods;
    } else {
      one = methods;
    }
  };
  var remove = function remove(id) {
    if (id) {
      delete all[id];
    } else {
      one = undefined;
    }
  };

  var useLatest = (function (val) {
    var ref = react.useRef(val);
    ref.current = val;
    return ref;
  });

  var arrayToMap = (function (arr, map) {
    if (map === void 0) {
      map = {};
    }

    return arr.reduce(function (obj, key) {
      obj[map[key] || key] = true;
      return obj;
    }, {});
  });

  var isFileList = (function (value) {
    return value instanceof FileList;
  });

  var isObject = (function (value) {
    return value !== null && typeof value === "object";
  });

  var cloneObject = function cloneObject(object) {
    if (object instanceof Event) throw new Error("Unable to clone event.");
    if (!isObject(object) || isFileList(object)) return object;
    if (object instanceof Date) return new Date(object.getTime());
    if (Array.isArray(object)) return object.map(function (val) {
      return cloneObject(val);
    });
    return Object.keys(object).reduce(function (obj, key) {
      obj[key] = cloneObject(object[key]);
      return obj;
    }, {});
  };

  var compact = (function (arr) {
    return arr.filter(Boolean);
  });

  var isPlainObject = (function (value) {
    return !Array.isArray(value) && !(value instanceof Date) && isObject(value);
  });

  var deepMerge = function deepMerge() {
    for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
      objects[_key] = arguments[_key];
    }

    return objects.reduce(function (prev, obj) {
      Object.keys(obj).forEach(function (key) {
        var prevValue = prev[key];
        var currValue = obj[key];

        if (Array.isArray(prevValue) && Array.isArray(currValue)) {
          prev[key] = [].concat(prevValue, currValue);
        } else if (isPlainObject(prevValue) && isPlainObject(currValue)) {
          prev[key] = deepMerge(prevValue, currValue);
        } else {
          prev[key] = currValue;
        }
      });
      return prev;
    }, {});
  };

  var isUndefined = (function (value) {
    return value === undefined;
  });

  var filterErrors = function filterErrors(error, touched) {
    if (!isPlainObject(error)) return touched ? error : undefined;
    return Object.keys(error).reduce(function (obj, key) {
      var nextErrors = filterErrors(error[key], touched[key] || false);

      if (!isUndefined(nextErrors)) {
        obj[key] = nextErrors;
      } else {
        delete obj[key];
      }

      return obj;
    }, {});
  };

  var stringToPath = (function (str) {
    if (typeof str !== "string") throw new TypeError("Expected a string.");
    if (!str.length) return [];
    return compact(str.split(/[.[\]]+/));
  });

  var get = (function (object, path, defaultValue) {
    if (!isPlainObject(object) || !path) return defaultValue;
    var value = stringToPath(path).reduce(function (obj, key) {
      return (obj || {})[key];
    }, object);
    return !isUndefined(value) ? value : defaultValue;
  });

  var getIsDirty = (function (dirty) {
    var search = function search(dty, found) {
      if (found === void 0) {
        found = [];
      }

      for (var _i = 0, _Object$values = Object.values(dty); _i < _Object$values.length; _i++) {
        var val = _Object$values[_i];

        if (val === true) {
          found.push(val);
          return found;
        }

        if (isObject(val)) search(val, found);
      }

      return found;
    };

    return !!search(dirty).length;
  });

  var getPath = (function (path) {
    return !["values", "touched", "errors", "isDirty", "dirty", "isValidating", "isValid", "isSubmitting", "isSubmitted", "submitCount"].some(function (key) {
      return path.startsWith(key);
    }) ? "values." + path : path;
  });

  var invariant = (function (condition, message) {
    if ("development" !== "production" && condition) throw new Error(message);
  });

  var isFunction = (function (value) {
    return typeof value === "function";
  });

  var isAsyncFunction = (function (value) {
    return isFunction(value) && value.constructor.name === "AsyncFunction";
  });

  var isCheckboxInput = (function (field) {
    return field.type === "checkbox";
  });

  var isEmptyObject = (function (value) {
    return isPlainObject(value) && !Object.keys(value).length;
  });

  var isFieldArray = (function (fields, name, callback) {
    var fieldName;
    Object.keys(fields).some(function (key) {
      if (name.startsWith(key)) {
        fieldName = key;
        if (callback) callback(key);
        return true;
      }

      return false;
    });
    return fieldName;
  });

  var isFieldElement = (function (element) {
    return /INPUT|TEXTAREA|SELECT/.test(element.tagName);
  });

  var isFileInput = (function (field) {
    return field.type === "file";
  });

  var isInputElement = (function (element) {
    return element.tagName === "INPUT";
  });

  var isNumberInput = (function (field) {
    return field.type === "number";
  });

  var isRadioInput = (function (field) {
    return field.type === "radio";
  });

  var isRangeInput = (function (field) {
    return field.type === "range";
  });

  var isSelectMultiple = (function (field) {
    return field.type === "select-multiple";
  });

  var isSelectOne = (function (field) {
    return field.type === "select-one";
  });

  var parseState = (function (path, state, pathHandler, stateHandler, isGetState) {
    if (pathHandler === void 0) {
      pathHandler = getPath;
    }

    if (!path) return isGetState ? state : undefined;
    var parsedState;

    if (Array.isArray(path)) {
      parsedState = path.map(function (p) {
        p = pathHandler(p);
        var value = get(state, p);
        return stateHandler ? stateHandler(p, value) : value;
      });
    } else if (isPlainObject(path)) {
      var paths = path;
      parsedState = Object.keys(paths).reduce(function (s, key) {
        path = pathHandler(paths[key]);
        var value = get(state, path);
        s[key] = stateHandler ? stateHandler(path, value) : value;
        return s;
      }, {});
    } else {
      path = pathHandler(path);
      var value = get(state, path);
      parsedState = stateHandler ? stateHandler(path, value) : value;
    }

    return parsedState;
  });

  var runWithLowPriority = (function (callback) {
    return (window.requestIdleCallback || function (cb) {
      var start = Date.now();
      return setTimeout(function () {
        return cb({
          didTimeout: false,
          timeRemaining:
          /* istanbul ignore next */
          function timeRemaining() {
            return Math.max(0, 50 - (Date.now() - start));
          }
        });
      }, 1);
    })(callback, {
      timeout: 2000
    });
  });

  var set = (function (object, path, value, immutable) {
    if (!isPlainObject(object)) throw new TypeError("Expected an object.");
    var newObject = immutable ? cloneObject(object) : object;
    var segs = stringToPath(path);
    segs.slice(0, -1).reduce(function (obj, key, idx) {
      var nextIsNumber = !Number.isNaN(+segs[idx + 1]);
      if (isPlainObject(obj[key]) && !nextIsNumber || Array.isArray(obj[key]) && nextIsNumber) return obj[key];
      obj[key] = nextIsNumber ? [] : {};
      return obj[key];
    }, newObject)[segs[segs.length - 1] || ""] = value;
    return newObject;
  });

  var setValuesAsTrue = function setValuesAsTrue(object) {
    if (!Array.isArray(object) && !isPlainObject(object)) return true;
    if (Array.isArray(object)) return object.map(function (val) {
      return setValuesAsTrue(val);
    });
    return Object.keys(object).reduce(function (obj, key) {
      obj[key] = setValuesAsTrue(object[key]);
      return obj;
    }, {});
  };

  var unset = function unset(object, path, immutable) {
    if (!isPlainObject(object)) throw new TypeError("Expected an object.");
    var refObject = immutable ? cloneObject(object) : object;
    var newObject = refObject; // eslint-disable-next-line no-prototype-builtins

    if (newObject.hasOwnProperty(path)) {
      delete newObject[path];
      return refObject;
    }

    var segs = stringToPath(path);
    if (!segs.length) return refObject;
    var last = segs.pop();
    var target = segs.reduce(function (obj, key) {
      return (obj || {})[key];
    }, newObject);

    if (Array.isArray(target)) {
      var index = +last;

      if (index < target.length - 1) {
        delete target[index];
      } else {
        while (index >= 0) {
          // @ts-expect-error
          if (index == last || isUndefined(target[index])) {
            target.splice(index, 1);
            index -= 1;
          } else {
            break;
          }
        }
      }
    } else if (isPlainObject(target)) {
      delete target[last];
    }

    return isEmptyObject(target) || Array.isArray(target) && !target.filter(function (t) {
      return !isUndefined(t);
    }).length ? unset(refObject, segs.join(".")) : refObject;
  };

  var warn = (function () {
    var _console;

    if ("development" !== "production") (_console = console).warn.apply(_console, arguments);
  });

  var useState = (function (initialState, onChange) {
    var _useReducer = react.useReducer(function (c) {
      return c + 1;
    }, 0),
        forceUpdate = _useReducer[1];

    var stateRef = react.useRef(initialState);
    var observersRef = react.useRef([{
      usedState: {},
      notify: forceUpdate
    }]);
    var onChangeRef = useLatest(onChange || function () {
      return undefined;
    });
    var setStateRef = react.useCallback(function (path, value, _temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          fieldPath = _ref.fieldPath,
          shouldSkipUpdate = _ref.shouldSkipUpdate,
          shouldForceUpdate = _ref.shouldForceUpdate;

      var key = path.split(".")[0];

      if (!key) {
        if (!dequal(stateRef.current, value)) {
          stateRef.current = value;
          onChangeRef.current(stateRef.current);
          observersRef.current.forEach(function (_ref2) {
            var usedState = _ref2.usedState,
                notify = _ref2.notify;
            return !isEmptyObject(usedState) && notify(stateRef.current);
          });
        }

        return;
      }

      if (path !== "values" && key === "values" || !dequal(get(stateRef.current, path), value)) {
        var state = set(stateRef.current, path, value, true);
        var errors = state.errors,
            dirty = state.dirty,
            prevIsDirty = state.isDirty,
            prevIsValid = state.isValid,
            prevSubmitCount = state.submitCount;
        var currSubmitCount = state.submitCount;
        var isDirty = key === "dirty" ? getIsDirty(dirty) : prevIsDirty;
        var isValid = key === "errors" ? isEmptyObject(errors) : prevIsValid;
        var submitCount = key === "isSubmitting" && value ? currSubmitCount += 1 : currSubmitCount;
        stateRef.current = _extends({}, state, {
          isDirty: isDirty,
          isValid: isValid,
          submitCount: submitCount
        });
        onChangeRef.current(stateRef.current);
        if (shouldSkipUpdate) return;
        path = fieldPath || path;
        observersRef.current.forEach(function (_ref3) {
          var usedState = _ref3.usedState,
              notify = _ref3.notify;
          return (shouldForceUpdate || Object.keys(usedState).some(function (k) {
            return path.startsWith(k) || k.startsWith(path);
          }) || usedState.isDirty && isDirty !== prevIsDirty || usedState.isValid && isValid !== prevIsValid || usedState.submitCount && submitCount !== prevSubmitCount) && notify(stateRef.current);
        });
      }
    }, [onChangeRef]);
    return {
      stateRef: stateRef,
      setStateRef: setStateRef,
      observersRef: observersRef
    };
  });

  var _excluded$1 = ["defaultValue"],
      _excluded2$1 = ["validate"];
  var useForm = (function (_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        id = _ref.id,
        _ref$defaultValues = _ref.defaultValues,
        defaultValues = _ref$defaultValues === void 0 ? {} : _ref$defaultValues,
        validate = _ref.validate,
        _ref$validateOnChange = _ref.validateOnChange,
        validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange,
        _ref$validateOnBlur = _ref.validateOnBlur,
        validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur,
        _ref$focusOnError = _ref.focusOnError,
        focusOnError = _ref$focusOnError === void 0 ? true : _ref$focusOnError,
        _ref$removeOnUnmounte = _ref.removeOnUnmounted,
        removeOnUnmounted = _ref$removeOnUnmounte === void 0 ? true : _ref$removeOnUnmounte,
        _ref$builtInValidatio = _ref.builtInValidationMode,
        builtInValidationMode = _ref$builtInValidatio === void 0 ? "message" : _ref$builtInValidatio,
        _ref$excludeFields = _ref.excludeFields,
        excludeFields = _ref$excludeFields === void 0 ? [] : _ref$excludeFields,
        onReset = _ref.onReset,
        onSubmit = _ref.onSubmit,
        onError = _ref.onError,
        onStateChange = _ref.onStateChange;

    var handlersRef = react.useRef({});
    var mutationObserverRef = react.useRef();
    var formRef = react.useRef();
    var fieldsRef = react.useRef(new Map());
    var fieldParsersRef = react.useRef({});
    var fieldArrayRef = react.useRef({});
    var controlsRef = react.useRef({});
    var formValidatorRef = useLatest(validate);
    var fieldValidatorsRef = react.useRef({});
    var changedFieldRef = react.useRef();
    var excludeFieldsRef = react.useRef(arrayToMap(excludeFields));
    var onResetRef = useLatest(onReset || function () {
      return undefined;
    });
    var onSubmitRef = useLatest(onSubmit || function () {
      return undefined;
    });
    var onErrorRef = useLatest(onError || function () {
      return undefined;
    });
    var hasWarnValues = react.useRef(false);
    var initialStateRef = react.useRef({
      values: defaultValues,
      touched: {},
      errors: {},
      isDirty: false,
      dirty: {},
      isValidating: false,
      isValid: true,
      isSubmitting: false,
      isSubmitted: false,
      submitCount: 0
    });

    var _useState = useState(_extends({}, initialStateRef.current), onStateChange),
        stateRef = _useState.stateRef,
        setStateRef = _useState.setStateRef,
        observersRef = _useState.observersRef;

    var handleUnset = react.useCallback(function (path, options) {
      var segs = path.split(".");
      var k = segs.shift();
      setStateRef(k, unset(stateRef.current[k], segs.join("."), true), _extends({
        fieldPath: path
      }, options));
    }, [setStateRef, stateRef]);
    var handleFocus = react.useCallback(function (name) {
      var _fieldsRef$current$ge, _fieldsRef$current$ge2;

      var field = ((_fieldsRef$current$ge = fieldsRef.current.get(name)) == null ? void 0 : _fieldsRef$current$ge.field) || ((_fieldsRef$current$ge2 = fieldsRef.current.get(Array.from(fieldsRef.current.keys()).find(function (n) {
        return n.startsWith(name);
      }) || "")) == null ? void 0 : _fieldsRef$current$ge2.field);
      if (field && isFunction(field.focus)) field.focus();
    }, []);
    var getFields = react.useCallback(function (form) {
      return Array.from(form.querySelectorAll("input,textarea,select")).filter(function (element) {
        var field = element;
        var type = field.type,
            name = field.name,
            fieldId = field.id,
            classList = field.classList,
            rcfExclude = field.dataset.rcfExclude;
        var exclude = excludeFieldsRef.current;
        if (/button|image|submit|reset/.test(type) || fieldId && exclude["#" + fieldId] || Array.from(classList).find(function (n) {
          return exclude["." + n];
        })) return false;

        if (rcfExclude !== "true" && !name) {
          warn('💡 react-cool-form > field: Missing "name" attribute. Do you want to exclude the field? See: https://react-cool-form.netlify.app/docs/api-reference/use-form/#excludefields');
          return false;
        }

        return controlsRef.current[name] || rcfExclude !== "true" && !exclude[name];
      }).reduce(function (acc, elm) {
        var _acc$get;

        var field = elm;
        var name = field.name;
        var fieldArrayName = isFieldArray(fieldArrayRef.current, name);
        if (fieldArrayName) fieldArrayRef.current[fieldArrayName].fields[name] = true;
        acc.set(name, _extends({}, acc.get(name), {
          field: ((_acc$get = acc.get(name)) == null ? void 0 : _acc$get.field) || field
        }));

        if (isCheckboxInput(field) || isRadioInput(field)) {
          acc.get(name).options = acc.get(name).options ? [].concat(acc.get(name).options, [field]) : [field];
        } else if (isSelectOne(field) || isSelectMultiple(field)) {
          acc.get(name).options = Array.from(field.options);
        }

        return acc;
      }, new Map());
    }, []);
    var getNodeValue = react.useCallback(function (name, fields) {
      var _find;

      if (fields === void 0) {
        fields = fieldsRef.current;
      }

      if (!fields.has(name)) return undefined;

      var _ref2 = fields.get(name),
          field = _ref2.field,
          options = _ref2.options;

      if (isInputElement(field)) {
        var _fieldParsersRef$curr, _fieldParsersRef$curr2;

        if ((_fieldParsersRef$curr = fieldParsersRef.current[name]) != null && _fieldParsersRef$curr.valueAsNumber) return field.valueAsNumber;
        if ((_fieldParsersRef$curr2 = fieldParsersRef.current[name]) != null && _fieldParsersRef$curr2.valueAsDate) return field.valueAsDate;
      }

      if (isNumberInput(field) || isRangeInput(field)) return field.valueAsNumber || "";

      if (isCheckboxInput(field)) {
        var checkboxes = options;
        if (checkboxes.length > 1) return checkboxes.filter(function (c) {
          return c.checked;
        }).map(function (c) {
          return c.value;
        });
        var checkbox = checkboxes[0];
        if (checkbox.hasAttribute("value") && checkbox.value) return checkbox.checked ? [checkbox.value] : [];
        return checkbox.checked;
      }

      if (isRadioInput(field)) return ((_find = options.find(function (radio) {
        return radio.checked;
      })) == null ? void 0 : _find.value) || "";
      if (isSelectMultiple(field)) return options.filter(function (option) {
        return option.selected;
      }).map(function (option) {
        return option.value;
      });
      if (isFileInput(field)) return field.files;
      return field.value;
    }, []);
    var setNodeValue = react.useCallback(function (name, value, fields) {
      if (fields === void 0) {
        fields = fieldsRef.current;
      }

      if (!fields.has(name) || controlsRef.current[name]) return;

      var _ref3 = fields.get(name),
          field = _ref3.field,
          options = _ref3.options;

      if (isCheckboxInput(field)) {
        var checkboxes = options;

        if (checkboxes.length > 1) {
          checkboxes.forEach(function (checkbox) {
            checkbox.checked = Array.isArray(value) ? value.includes(checkbox.value) : !!value;
          });
        } else {
          checkboxes[0].checked = !!value;
        }
      } else if (isRadioInput(field)) {
        options.forEach(function (radio) {
          radio.checked = radio.value === value;
        });
      } else if (isSelectMultiple(field) && Array.isArray(value)) {
        options.forEach(function (option) {
          option.selected = !!value.includes(option.value);
        });
      } else if (isFileInput(field)) {
        if (isFileList(value)) field.files = value;
        if (!value) field.value = "";
      } else {
        field.value = value != null ? value : "";
      }
    }, []);
    var setDefaultValue = react.useCallback(function (name, value, shouldUpdateDefaultValue) {
      if (shouldUpdateDefaultValue === void 0) {
        shouldUpdateDefaultValue = !isFieldArray(fieldArrayRef.current, name) || !isUndefined(get(initialStateRef.current.values, name.split(".")[0]));
      }

      if (shouldUpdateDefaultValue) initialStateRef.current.values = set(initialStateRef.current.values, name, value, true);
      if (!dequal(get(stateRef.current.values, name), value)) setStateRef("values." + name, value, {
        shouldSkipUpdate: true
      });
    }, [setStateRef, stateRef]);
    var setNodesOrValues = react.useCallback(function (values, _temp2) {
      var _ref4 = _temp2 === void 0 ? {} : _temp2,
          _ref4$shouldSetValues = _ref4.shouldSetValues,
          shouldSetValues = _ref4$shouldSetValues === void 0 ? true : _ref4$shouldSetValues,
          _ref4$fields = _ref4.fields,
          fields = _ref4$fields === void 0 ? Array.from(fieldsRef.current.keys()) : _ref4$fields;

      return fields.forEach(function (name) {
        if (controlsRef.current[name]) return;
        var value = get(values, name);
        if (!isUndefined(value)) setNodeValue(name, value);
        if (shouldSetValues) setDefaultValue(name, !isUndefined(value) ? value : getNodeValue(name));
      });
    }, [getNodeValue, setDefaultValue, setNodeValue]);
    var setError = react.useCallback(function (name, error) {
      error = isFunction(error) ? error(get(stateRef.current.errors, name)) : error;

      if (error) {
        setStateRef("errors." + name, error);
      } else {
        handleUnset("errors." + name);
      }
    }, [handleUnset, setStateRef, stateRef]);
    var clearErrors = react.useCallback(function (name) {
      if (!name) {
        setStateRef("errors", {});
      } else if (Array.isArray(name)) {
        name.forEach(function (n) {
          return setError(n);
        });
      } else {
        setError(name);
      }
    }, [setError, setStateRef]);
    var runBuiltInValidation = react.useCallback(function (name) {
      if (builtInValidationMode === false || !fieldsRef.current.has(name)) return undefined;

      var _ref5 = fieldsRef.current.get(name),
          _ref5$field = _ref5.field,
          validity = _ref5$field.validity,
          validationMessage = _ref5$field.validationMessage;

      if (builtInValidationMode === "state") for (var k in validity) {
        if (k !== "valid" && validity[k]) return k;
      }
      return validationMessage;
    }, [builtInValidationMode]);
    var runAllBuiltInValidation = react.useCallback(function () {
      if (builtInValidationMode === false) return {};
      return Array.from(fieldsRef.current.keys()).reduce(function (errors, name) {
        var error = runBuiltInValidation(name);
        errors = _extends({}, errors, error ? set(errors, name, error) : {});
        return errors;
      }, {});
    }, [builtInValidationMode, runBuiltInValidation]);
    var runFieldValidation = react.useCallback(async function (name) {
      var value = get(stateRef.current.values, name);
      if (!fieldValidatorsRef.current[name] || isUndefined(value)) return undefined;

      try {
        var error = await fieldValidatorsRef.current[name](value, stateRef.current.values);
        return error;
      } catch (exception) {
        warn("\uD83D\uDCA1 react-cool-form > validate " + name + ": ", exception);
        throw exception;
      }
    }, [stateRef]);
    var runAllFieldsValidation = react.useCallback(function () {
      var promises = Object.keys(fieldValidatorsRef.current).map(function (name) {
        return runFieldValidation(name);
      });
      return Promise.all(promises).then(function (errors) {
        return Object.keys(fieldValidatorsRef.current).reduce(function (acc, cur, idx) {
          acc = _extends({}, acc, errors[idx] ? set(acc, cur, errors[idx]) : {});
          return acc;
        }, {});
      });
    }, [runFieldValidation]);
    var runFormValidation = react.useCallback(async function (name) {
      if (!formValidatorRef.current) return name ? undefined : {};

      try {
        var errors = await formValidatorRef.current(stateRef.current.values);
        if (name) return get(errors, name);
        return isPlainObject(errors) ? errors : {};
      } catch (exception) {
        warn("\uD83D\uDCA1 react-cool-form > validate form: ", exception);
        throw exception;
      }
    }, [formValidatorRef, stateRef]);
    var validateField = react.useCallback(async function (name) {
      var hasAsyncValidator = isAsyncFunction(formValidatorRef.current) || isAsyncFunction(fieldValidatorsRef.current[name]);
      if (hasAsyncValidator) setStateRef("isValidating", true);

      try {
        var error = (await runFormValidation(name)) || (await runFieldValidation(name)) || runBuiltInValidation(name);
        setError(name, error);
        if (hasAsyncValidator) setStateRef("isValidating", false);
        return error;
      } catch (exception) {
        return exception;
      }
    }, [formValidatorRef, runBuiltInValidation, runFieldValidation, runFormValidation, setError, setStateRef]);
    var validateFieldWithLowPriority = react.useCallback(function (name) {
      return runWithLowPriority(function () {
        return validateField(name);
      });
    }, [validateField]);
    var validateForm = react.useCallback(function () {
      setStateRef("isValidating", true);
      return Promise.all([runAllBuiltInValidation(), runAllFieldsValidation(), runFormValidation()]).then(function (errors) {
        var errs = deepMerge.apply(void 0, errors);
        setStateRef("errors", errs);
        setStateRef("isValidating", false);
        return errs;
      });
    }, [runAllBuiltInValidation, runAllFieldsValidation, runFormValidation, setStateRef]);
    var runValidation = react.useCallback(function (name, _temp3) {
      var _ref6 = _temp3 === void 0 ? {} : _temp3,
          _ref6$shouldFocus = _ref6.shouldFocus,
          shouldFocus = _ref6$shouldFocus === void 0 ? focusOnError : _ref6$shouldFocus;

      var names = [];

      if (shouldFocus) {
        names = Array.isArray(shouldFocus) ? shouldFocus : Array.from(fieldsRef.current.keys());
        names = isFunction(shouldFocus) ? shouldFocus(names) : names;
      }

      if (!name) return validateForm().then(function (errors) {
        if (shouldFocus) {
          var fieldName = names.find(function (n) {
            return get(errors, n);
          });
          if (fieldName) handleFocus(fieldName);
        }

        return isEmptyObject(errors);
      });
      if (Array.isArray(name)) return Promise.all(name.map(function (n) {
        return validateField(n);
      })).then(function (errors) {
        if (shouldFocus) {
          var fieldName = names.find(function (n) {
            return !!errors[name.indexOf(n)];
          });
          if (fieldName) handleFocus(fieldName);
        }

        return !compact(errors).length;
      });
      return validateField(name).then(function (error) {
        if (shouldFocus && error && names.includes(name)) handleFocus(name);
        return !error;
      });
    }, // eslint-disable-next-line react-hooks/exhaustive-deps
    [handleFocus, validateField, validateForm]);
    var getFormState = react.useCallback(function (path, _temp4) {
      var _ref7 = _temp4 === void 0 ? {} : _temp4,
          errorWithTouched = _ref7.errorWithTouched,
          _ref7$defaultValues = _ref7.defaultValues,
          dfValues = _ref7$defaultValues === void 0 ? {} : _ref7$defaultValues,
          _ref7$methodName = _ref7.methodName,
          methodName = _ref7$methodName === void 0 ? "getState" : _ref7$methodName,
          callback = _ref7.callback;

      var usedState = {};
      var state = parseState(path, stateRef.current, function (p) {
        p = getPath(p);

        if (methodName !== "getState") {
          if (p === "values" && methodName !== "useFormStateCallback" && !hasWarnValues.current) {
            warn("\uD83D\uDCA1 react-cool-form > " + methodName + ": Getting \"values\" alone might cause unnecessary re-renders. If you know what you're doing, just ignore this warning. See: https://react-cool-form.netlify.app/docs/getting-started/form-state#best-practices");
            hasWarnValues.current = true;
          }

          usedState[p] = true;
        }

        return p;
      }, function (p, v) {
        if (methodName === "getState") return v;

        if (p.startsWith("values")) {
          if (!isUndefined(v)) return v;
          p = p.replace("values.", "");
          v = get(initialStateRef.current, p);
          return !isUndefined(v) ? v : get(dfValues, p);
        }

        if (!errorWithTouched || !p.startsWith("errors")) return v;
        p = p.replace("errors", "touched");
        usedState[p] = true;
        return filterErrors(v, get(stateRef.current, p));
      }, methodName === "getState");
      if (callback) callback(usedState);
      return state;
    }, [stateRef]);
    var focus = react.useCallback(function (name, delay) {
      if (!isUndefined(delay)) {
        setTimeout(function () {
          return handleFocus(name);
        }, delay);
      } else {
        handleFocus(name);
      }
    }, [handleFocus]);
    var use = react.useCallback(function (path, _temp5) {
      var _ref8 = _temp5 === void 0 ? {} : _temp5,
          errorWithTouched = _ref8.errorWithTouched,
          dfValues = _ref8.defaultValues;

      return getFormState(path, {
        errorWithTouched: errorWithTouched,
        defaultValues: dfValues,
        methodName: "use",
        callback: function callback(usedState) {
          observersRef.current[0].usedState = _extends({}, observersRef.current[0].usedState, usedState);
        }
      });
    }, [getFormState, observersRef]);
    var getState = react.useCallback(function (path) {
      return getFormState(path);
    }, [getFormState]);
    var setTouched = react.useCallback(function (name, isTouched, _temp6) {
      if (isTouched === void 0) {
        isTouched = true;
      }

      var _ref9 = _temp6 === void 0 ? {} : _temp6,
          _ref9$shouldValidate = _ref9.shouldValidate,
          shouldValidate = _ref9$shouldValidate === void 0 ? validateOnBlur : _ref9$shouldValidate;

      if (isTouched) {
        setStateRef("touched." + name, true);
      } else {
        handleUnset("touched." + name);
      }

      if (shouldValidate) validateFieldWithLowPriority(name);
    }, [handleUnset, setStateRef, validateFieldWithLowPriority, validateOnBlur]);
    var setTouchedMaybeValidate = react.useCallback(function (name) {
      return setTouched(name, true, {
        shouldValidate: validateOnChange ? name !== changedFieldRef.current : undefined
      });
    }, [setTouched, validateOnChange]);
    var setDirty = react.useCallback(function (name, isDirty) {
      if (isDirty === void 0) {
        isDirty = true;
      }

      if (isDirty) {
        setStateRef("dirty." + name, true);
      } else {
        handleUnset("dirty." + name);
      }
    }, [handleUnset, setStateRef]);
    var setDirtyIfNeeded = react.useCallback(function (name) {
      return setDirty(name, !dequal(get(stateRef.current.values, name), get(initialStateRef.current.values, name)));
    }, [setDirty, stateRef]);
    var setValue = react.useCallback(function (name, value, _temp7) {
      var _ref10 = _temp7 === void 0 ? {} : _temp7,
          _ref10$shouldValidate = _ref10.shouldValidate,
          shouldValidate = _ref10$shouldValidate === void 0 ? validateOnChange : _ref10$shouldValidate,
          _ref10$shouldTouched = _ref10.shouldTouched,
          shouldTouched = _ref10$shouldTouched === void 0 ? true : _ref10$shouldTouched,
          _ref10$shouldDirty = _ref10.shouldDirty,
          shouldDirty = _ref10$shouldDirty === void 0 ? true : _ref10$shouldDirty;

      value = isFunction(value) ? value(get(stateRef.current.values, name)) : value;

      if (!isUndefined(value)) {
        setStateRef("values." + name, value);
      } else {
        handleUnset("values." + name);
      }

      setNodeValue(name, value);
      isFieldArray(fieldArrayRef.current, name, function (key) {
        return fieldArrayRef.current[key].reset();
      });
      if (shouldTouched) setTouched(name, true, {
        shouldValidate: false
      });
      if (shouldDirty) setDirtyIfNeeded(name);
      if (shouldValidate) validateFieldWithLowPriority(name);
    }, [handleUnset, setDirtyIfNeeded, setNodeValue, setStateRef, setTouched, stateRef, validateFieldWithLowPriority, validateOnChange]);
    var getOptions = react.useCallback(function () {
      return {
        getState: getState,
        setValue: setValue,
        setTouched: setTouched,
        setDirty: setDirty,
        setError: setError,
        clearErrors: clearErrors,
        runValidation: runValidation,
        removeField: removeField,
        focus: focus,
        reset: reset,
        submit: submit
      };
    }, // eslint-disable-next-line react-hooks/exhaustive-deps
    []);
    var reset = react.useCallback(function (values, exclude, e) {
      if (e != null && e.preventDefault) e.preventDefault();
      if (e != null && e.stopPropagation) e.stopPropagation();

      var state = _extends({}, stateRef.current);

      var skip = arrayToMap(exclude || []);
      Object.keys(state).forEach(function (key) {
        if (skip[key]) return;

        if (key === "values") {
          var nextValues = (isFunction(values) ? values(stateRef.current.values) : values) || initialStateRef.current.values;
          state[key] = nextValues;
          initialStateRef.current.values = nextValues;
          setNodesOrValues(nextValues, {
            shouldSetValues: false,
            fields: Array.from(fieldsRef.current.keys()).filter(function (name) {
              return !isFieldArray(fieldArrayRef.current, name);
            })
          });
        } else {
          // @ts-expect-error
          state[key] = initialStateRef.current[key];
        }
      });
      setStateRef("", state);
      onResetRef.current(state.values, getOptions(), e);
      Object.values(fieldArrayRef.current).forEach(function (field) {
        return field.reset();
      });
    }, [getOptions, onResetRef, setNodesOrValues, setStateRef, stateRef]);
    var submit = react.useCallback(async function (e) {
      if (e != null && e.preventDefault) e.preventDefault();
      if (e != null && e.stopPropagation) e.stopPropagation();
      var nextTouched = [].concat(Array.from(fieldsRef.current.keys()), Object.keys(controlsRef.current)).reduce(function (touched, name) {
        touched = set(touched, name, true, true);
        return touched;
      }, stateRef.current.touched);
      setStateRef("touched", nextTouched);
      setStateRef("isSubmitted", false);
      setStateRef("isSubmitting", true);

      try {
        var isValid = await runValidation();

        if (!isValid) {
          var errors = stateRef.current.errors;
          onErrorRef.current(errors, getOptions(), e);
          return {
            errors: errors
          };
        }

        await onSubmitRef.current(stateRef.current.values, getOptions(), e);
        setStateRef("isSubmitted", true);
        return {
          values: stateRef.current.values
        };
      } catch (exception) {
        warn("\uD83D\uDCA1 react-cool-form > submit: ", exception);
        throw exception;
      } finally {
        setStateRef("isSubmitting", false);
      }
    }, [getOptions, onErrorRef, onSubmitRef, runValidation, setStateRef, stateRef]);
    var handleChangeEvent = react.useCallback(function (name, value) {
      setStateRef("values." + name, value);
      setDirtyIfNeeded(name);
      if (validateOnChange) validateFieldWithLowPriority(name);
    }, [setDirtyIfNeeded, setStateRef, validateFieldWithLowPriority, validateOnChange]);
    var shouldRemoveField = react.useCallback(function (name) {
      if (!removeOnUnmounted) return false;
      var names = Array.isArray(removeOnUnmounted) ? removeOnUnmounted : [].concat(Array.from(fieldsRef.current.keys()), Object.keys(controlsRef.current), Object.keys(fieldArrayRef.current));
      names = isFunction(removeOnUnmounted) ? removeOnUnmounted(names) : names;
      return names.includes(name);
    }, // eslint-disable-next-line react-hooks/exhaustive-deps
    []);
    var removeField = react.useCallback(function (name, exclude) {
      var _arrayToMap = arrayToMap(exclude || [], {
        value: "values",
        error: "errors"
      }),
          defaultValue = _arrayToMap.defaultValue,
          rest = _objectWithoutPropertiesLoose(_arrayToMap, _excluded$1);

      if (!defaultValue) initialStateRef.current.values = unset(initialStateRef.current.values, name, true);
      ["values", "touched", "dirty", "errors"].forEach(function (key, idx, arr) {
        var shouldForceUpdate = idx === arr.length - 1;
        if (!rest[key] && !isUndefined(get(stateRef.current[key], name))) handleUnset(key + "." + name, {
          shouldSkipUpdate: !shouldForceUpdate,
          shouldForceUpdate: shouldForceUpdate
        });
      });
      delete fieldParsersRef.current[name];
      delete fieldValidatorsRef.current[name];
      delete fieldArrayRef.current[name];
      delete controlsRef.current[name];
      if (fieldsRef.current.has(name)) fieldsRef.current["delete"](name);
    }, [handleUnset, stateRef]);
    var registerForm = react.useCallback(function (el) {
      if (!el) return;
      formRef.current = el;
      var form = formRef.current;
      fieldsRef.current = getFields(form);
      setNodesOrValues(initialStateRef.current.values);

      handlersRef.current.change = function (_ref11) {
        var target = _ref11.target;
        var _ref12 = target,
            name = _ref12.name;

        if (fieldsRef.current.has(name) && !controlsRef.current[name]) {
          var _fieldParsersRef$curr3;

          var parse = (_fieldParsersRef$curr3 = fieldParsersRef.current[name]) == null ? void 0 : _fieldParsersRef$curr3.parse;
          var value = getNodeValue(name);
          handleChangeEvent(name, parse ? parse(value) : value);
          changedFieldRef.current = name;
        }
      };

      handlersRef.current.blur = function (_ref13) {
        var target = _ref13.target;
        if (!isFieldElement(target)) return;
        var _ref14 = target,
            name = _ref14.name;

        if (fieldsRef.current.has(name) && !controlsRef.current[name]) {
          setTouchedMaybeValidate(name);
          changedFieldRef.current = undefined;
        }
      };

      handlersRef.current.submit = function (e) {
        return submit(e);
      };

      handlersRef.current.reset = function (e) {
        return reset(null, null, e);
      };

      form.addEventListener("input", handlersRef.current.change);
      form.addEventListener("focusout", handlersRef.current.blur);
      form.addEventListener("submit", handlersRef.current.submit);
      form.addEventListener("reset", handlersRef.current.reset);
      mutationObserverRef.current = new MutationObserver(function (_ref15) {
        var type = _ref15[0].type;
        if (type !== "childList") return;
        var fields = getFields(form);
        var values = initialStateRef.current.values;
        fieldsRef.current.forEach(function (_, name) {
          var _fieldsRef$current$ge3, _fieldsRef$current$ge4, _fields$get$options;

          if (!shouldRemoveField(name)) return;
          if (controlsRef.current[name]) return;

          if (!fields.has(name)) {
            removeField(name, !isFieldArray(fieldArrayRef.current, name) || isUndefined(get(initialStateRef.current.values, name.split(".")[0])) ? undefined : ["defaultValue"]);
            return;
          }

          var currOptions = (_fieldsRef$current$ge3 = fieldsRef.current.get(name)) == null ? void 0 : (_fieldsRef$current$ge4 = _fieldsRef$current$ge3.options) == null ? void 0 : _fieldsRef$current$ge4.length;
          var nextOptions = (_fields$get$options = fields.get(name).options) == null ? void 0 : _fields$get$options.length;

          if (currOptions > nextOptions) {
            setStateRef("values." + name, getNodeValue(name, fields), {
              shouldSkipUpdate: true
            });
          } else if (currOptions < nextOptions) {
            setNodeValue(name, get(values, name), fields);
          }
        });
        var addedNodes = [];
        fields.forEach(function (_, name) {
          if (fieldsRef.current.has(name) || controlsRef.current[name]) return;
          var value = get(stateRef.current.values, name);
          if (!isUndefined(value)) values = set(values, name, value, true);
          addedNodes.push(name);
        });
        fieldsRef.current = fields;
        if (addedNodes.length) setNodesOrValues(values, {
          fields: addedNodes
        });
      });
      mutationObserverRef.current.observe(form, {
        childList: true,
        subtree: true
      });
    }, [getFields, getNodeValue, handleChangeEvent, removeField, reset, setNodeValue, setNodesOrValues, setStateRef, setTouchedMaybeValidate, shouldRemoveField, stateRef, submit]);
    var registerField = react.useCallback(function (value) {
      return function (field) {
        if (!(field != null && field.name) || controlsRef.current[field.name] || excludeFieldsRef.current[field.name]) return;

        if (isFunction(value)) {
          fieldValidatorsRef.current[field.name] = value;
          return;
        }

        var validator = value.validate,
            parsers = _objectWithoutPropertiesLoose(value, _excluded2$1);

        if (validator) fieldValidatorsRef.current[field.name] = validator;
        fieldParsersRef.current[field.name] = parsers;
      };
    }, []);
    set$1(id, {
      validateOnChange: validateOnChange,
      shouldRemoveField: shouldRemoveField,
      initialStateRef: initialStateRef,
      fieldArrayRef: fieldArrayRef,
      controlsRef: controlsRef,
      observersRef: observersRef,
      fieldValidatorsRef: fieldValidatorsRef,
      changedFieldRef: changedFieldRef,
      setStateRef: setStateRef,
      getNodeValue: getNodeValue,
      getFormState: getFormState,
      setDefaultValue: setDefaultValue,
      setNodesOrValues: setNodesOrValues,
      setTouchedMaybeValidate: setTouchedMaybeValidate,
      handleChangeEvent: handleChangeEvent,
      removeField: removeField,
      form: registerForm,
      field: registerField,
      focus: focus,
      use: use,
      getState: getState,
      setValue: setValue,
      setTouched: setTouched,
      setDirty: setDirty,
      setError: setError,
      clearErrors: clearErrors,
      runValidation: runValidation,
      reset: reset,
      submit: submit
    });
    react.useEffect(function () {
      return function () {
        if (formRef.current) {
          var _mutationObserverRef$;

          var handlers = handlersRef.current;
          formRef.current.removeEventListener("input", handlers.change);
          formRef.current.removeEventListener("focusout", handlers.blur);
          formRef.current.removeEventListener("submit", handlers.submit);
          formRef.current.removeEventListener("reset", handlers.reset);
          (_mutationObserverRef$ = mutationObserverRef.current) == null ? void 0 : _mutationObserverRef$.disconnect();
        }

        remove(id);
      };
    }, [id]);
    return {
      form: registerForm,
      field: registerField,
      focus: focus,
      removeField: removeField,
      use: use,
      getState: getState,
      setValue: setValue,
      setTouched: setTouched,
      setDirty: setDirty,
      setError: setError,
      clearErrors: clearErrors,
      runValidation: runValidation,
      reset: reset,
      submit: submit
    };
  });

  var useFormMethods = (function (formId) {
    var methods = get$1(formId);
    invariant(!methods, '💡 react-cool-form > useFormMethods: It must work with an "useForm" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form');
    var form = methods.form,
        field = methods.field,
        focus = methods.focus,
        removeField = methods.removeField,
        use = methods.use,
        getState = methods.getState,
        setValue = methods.setValue,
        setTouched = methods.setTouched,
        setDirty = methods.setDirty,
        setError = methods.setError,
        clearErrors = methods.clearErrors,
        runValidation = methods.runValidation,
        reset = methods.reset,
        submit = methods.submit;
    return {
      form: form,
      field: field,
      focus: focus,
      removeField: removeField,
      use: use,
      getState: getState,
      setValue: setValue,
      setTouched: setTouched,
      setDirty: setDirty,
      setError: setError,
      clearErrors: clearErrors,
      runValidation: runValidation,
      reset: reset,
      submit: submit
    };
  });

  var useFormState = (function (path, configOrCallback, formId) {
    var config = !isFunction(configOrCallback) ? configOrCallback : {};
    var methods = get$1((config == null ? void 0 : config.formId) || formId);
    invariant(!methods, "\uD83D\uDCA1 react-cool-form > useFormState: It must work with an \"useForm\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form");
    var observerRef = react.useRef();

    var _useReducer = react.useReducer(function (c) {
      return c + 1;
    }, 0),
        forceUpdate = _useReducer[1];

    var observersRef = methods.observersRef,
        getFormState = methods.getFormState;

    var _callback = isFunction(configOrCallback) ? configOrCallback : undefined;

    react.useEffect(function () {
      observersRef.current.push(observerRef.current);
      return function () {
        observersRef.current = observersRef.current.filter(function (o) {
          return o !== observerRef.current;
        });
      }; // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    return getFormState(path, _extends({}, config, {
      methodName: _callback ? "useFormStateCallback" : "useFormState",
      callback: function callback(usedState) {
        if (!observerRef.current) observerRef.current = {
          usedState: usedState,
          notify: _callback ? function (state) {
            return _callback(parseState(path, state));
          } : forceUpdate
        };
      }
    }));
  });

  var _excluded = ["formId", "defaultValue", "validate", "parse", "format", "errorWithTouched"],
      _excluded2 = ["onChange", "onBlur"];
  var useControlled = (function (name, _temp) {
    var _ref2;

    var _ref = _temp === void 0 ? {} : _temp,
        formId = _ref.formId,
        defaultValue = _ref.defaultValue,
        validate = _ref.validate,
        parse = _ref.parse,
        format = _ref.format,
        errorWithTouched = _ref.errorWithTouched,
        props = _objectWithoutPropertiesLoose(_ref, _excluded);

    var methods = get$1(formId);
    invariant(!methods, '💡 react-cool-form > useControlled: It must work with an "useForm" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form');
    var meta = useFormState({
      value: "values." + name,
      error: "errors." + name,
      isTouched: "touched." + name,
      isDirty: "dirty." + name
    }, {
      formId: formId,
      errorWithTouched: errorWithTouched
    });
    var shouldRemoveField = methods.shouldRemoveField,
        initialStateRef = methods.initialStateRef,
        fieldArrayRef = methods.fieldArrayRef,
        controlsRef = methods.controlsRef,
        fieldValidatorsRef = methods.fieldValidatorsRef,
        changedFieldRef = methods.changedFieldRef,
        getState = methods.getState,
        getNodeValue = methods.getNodeValue,
        setDefaultValue = methods.setDefaultValue,
        setTouchedMaybeValidate = methods.setTouchedMaybeValidate,
        handleChangeEvent = methods.handleChangeEvent,
        removeField = methods.removeField;
    react.useEffect(function () {
      var isFieldArr = isFieldArray(fieldArrayRef.current, name);
      var initialVal = get(initialStateRef.current.values, name);

      if (isUndefined(initialVal)) {
        if (!isUndefined(defaultValue) && (!isFieldArr || !isUndefined(get(initialStateRef.current.values, name.split(".")[0])))) {
          setDefaultValue(name, defaultValue);
        } else if (!isFieldArr) {
          warn("\uD83D\uDCA1 react-cool-form > useControlled: Please provide a default value for \"" + name + "\" field.");
        }
      } else if (isUndefined(getState(name))) {
        setDefaultValue(name, initialVal);
      }

      return function () {
        if (shouldRemoveField(name)) removeField(name, !isFieldArr || isUndefined( // eslint-disable-next-line react-hooks/exhaustive-deps
        get(initialStateRef.current.values, name.split(".")[0])) ? undefined : ["defaultValue"]);
      };
    }, // eslint-disable-next-line react-hooks/exhaustive-deps
    []);
    controlsRef.current[name] = true;
    if (validate) fieldValidatorsRef.current[name] = validate;

    var _onChange = props.onChange,
        _onBlur = props.onBlur,
        restProps = _objectWithoutPropertiesLoose(props, _excluded2);

    var value = get(initialStateRef.current.values, name);
    value = !isUndefined(value) ? value : defaultValue;
    value = !isUndefined(meta.value) ? meta.value : value;
    value = (_ref2 = format ? format(value) : value) != null ? _ref2 : "";
    return [_extends({
      name: name,
      value: value,
      onChange: function onChange() {
        var val;

        if (parse) {
          val = parse.apply(void 0, arguments);
        } else {
          var e = arguments.length <= 0 ? undefined : arguments[0];
          val = (e == null ? void 0 : e.nativeEvent) instanceof Event && isFieldElement(e.target) ? getNodeValue(name) : e;
        }

        handleChangeEvent(name, val);
        if (_onChange) _onChange.apply(void 0, arguments);
        changedFieldRef.current = name;
      },
      onBlur: function onBlur(e) {
        setTouchedMaybeValidate(name);
        if (_onBlur) _onBlur(e);
        changedFieldRef.current = undefined;
      }
    }, restProps), {
      error: meta.error,
      isTouched: !!meta.isTouched,
      isDirty: !!meta.isDirty
    }];
  });

  var useFieldArray = (function (name, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        formId = _ref.formId,
        defaultValue = _ref.defaultValue,
        validate = _ref.validate;

    var methods = get$1(formId);
    invariant(!methods, '💡 react-cool-form > useFieldArray: It must work with an "useForm" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form');
    var validateOnChange = methods.validateOnChange,
        shouldRemoveField = methods.shouldRemoveField,
        initialStateRef = methods.initialStateRef,
        fieldArrayRef = methods.fieldArrayRef,
        fieldValidatorsRef = methods.fieldValidatorsRef,
        getState = methods.getState,
        setDefaultValue = methods.setDefaultValue,
        setNodesOrValues = methods.setNodesOrValues,
        setStateRef = methods.setStateRef,
        runValidation = methods.runValidation,
        removeField = methods.removeField;
    var getFields = react.useCallback(function (init) {
      if (init === void 0) {
        init = false;
      }

      var fields = getState(name);
      if (init && isUndefined(fields)) fields = defaultValue;
      return Array.isArray(fields) ? fields.map(function (_, index) {
        return name + "[" + index + "]";
      }) : [];
    }, // eslint-disable-next-line react-hooks/exhaustive-deps
    [getState, name]);

    var _useState = react.useState(getFields(true)),
        fields = _useState[0],
        setFields = _useState[1];

    var updateFields = react.useCallback(function () {
      setFields(getFields());
      setNodesOrValues(getState("values"), {
        shouldSetValues: false,
        fields: Object.keys(fieldArrayRef.current[name].fields)
      });
    }, [fieldArrayRef, getFields, getState, name, setNodesOrValues]);
    react.useEffect(function () {
      if (isUndefined(get(initialStateRef.current.values, name)) && !isUndefined(defaultValue)) {
        setDefaultValue(name, defaultValue, true);
        updateFields();
      }

      return function () {
        if (shouldRemoveField(name)) removeField(name);
      }; // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    if (!fieldArrayRef.current[name]) fieldArrayRef.current[name] = {
      reset: updateFields,
      fields: {}
    };
    if (validate) fieldValidatorsRef.current[name] = validate;
    var setState = react.useCallback(function (handler, _temp2) {
      var _ref2 = _temp2 === void 0 ? {} : _temp2,
          shouldTouched = _ref2.shouldTouched,
          shouldDirty = _ref2.shouldDirty;

      var state = getState();
      ["values", "touched", "errors", "dirty"].forEach(function (key) {
        var _state$values$name, _extends2;

        var value = state[key][name];
        var fieldsLength = (_state$values$name = state.values[name]) == null ? void 0 : _state$values$name.length;
        if (key === "values" || key === "touched" && shouldTouched || key === "dirty" && shouldDirty || !isUndefined(value)) state = set(state, key, _extends({}, state[key], (_extends2 = {}, _extends2[name] = handler(Array.isArray(value) ? [].concat(value) : [], key, fieldsLength ? fieldsLength - 1 : 0), _extends2)), true);
      });
      setStateRef("", _extends({}, state, {
        shouldDirty: getIsDirty(state.dirty)
      }));
      updateFields();
      if (validateOnChange) runValidation(name);
    }, [getState, name, runValidation, setStateRef, updateFields, validateOnChange]);
    var push = react.useCallback(function (value, _temp3) {
      var _ref3 = _temp3 === void 0 ? {} : _temp3,
          shouldTouched = _ref3.shouldTouched,
          _ref3$shouldDirty = _ref3.shouldDirty,
          shouldDirty = _ref3$shouldDirty === void 0 ? true : _ref3$shouldDirty;

      var handler = function handler(f, type, lastIndex) {
        if (lastIndex === void 0) {
          lastIndex = 0;
        }

        if (type === "values") {
          f.push(value);
        } else if (type === "touched" && shouldTouched || type === "dirty" && shouldDirty) {
          f[lastIndex] = setValuesAsTrue(value);
        }

        return f;
      };

      setState(handler, {
        shouldTouched: shouldTouched,
        shouldDirty: shouldDirty
      });
    }, [setState]);
    var insert = react.useCallback(function (index, value, _temp4) {
      var _ref4 = _temp4 === void 0 ? {} : _temp4,
          shouldTouched = _ref4.shouldTouched,
          _ref4$shouldDirty = _ref4.shouldDirty,
          shouldDirty = _ref4$shouldDirty === void 0 ? true : _ref4$shouldDirty;

      var handler = function handler(f, type) {
        if (type === "values") {
          f.splice(index, 0, value);
        } else if (type === "touched" && shouldTouched || type === "dirty" && shouldDirty) {
          f[index] = setValuesAsTrue(value);
        } else if (index < f.length) {
          f.splice(index, 0, undefined);
        }

        return f;
      };

      setState(handler, {
        shouldTouched: shouldTouched,
        shouldDirty: shouldDirty
      });
    }, [setState]);
    var remove = react.useCallback(function (index) {
      var handler = function handler(f) {
        f.splice(index, 1);
        return compact(f).length ? f : [];
      };

      var value = (getState(name) || [])[index];
      setState(handler);
      return value;
    }, [getState, name, setState]);
    var swap = react.useCallback(function (indexA, indexB) {
      var handler = function handler(f) {
        var _ref5 = [f[indexB], f[indexA]];
        f[indexA] = _ref5[0];
        f[indexB] = _ref5[1];
        return f;
      };

      setState(handler);
    }, [setState]);
    var move = react.useCallback(function (from, to) {
      var handler = function handler(f) {
        f.splice(to, 0, f.splice(from, 1)[0]);
        return f;
      };

      setState(handler);
    }, [setState]);
    return [fields, {
      push: push,
      insert: insert,
      remove: remove,
      swap: swap,
      move: move
    }];
  });

  exports.get = get;
  exports.set = set;
  exports.unset = unset;
  exports.useControlled = useControlled;
  exports.useFieldArray = useFieldArray;
  exports.useForm = useForm;
  exports.useFormMethods = useFormMethods;
  exports.useFormState = useFormState;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.development.js.map
