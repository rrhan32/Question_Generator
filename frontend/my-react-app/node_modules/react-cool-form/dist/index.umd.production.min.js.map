{"version":3,"file":"index.umd.production.min.js","sources":["../node_modules/dequal/lite/index.mjs","../src/shared.ts","../src/hooks/useLatest.ts","../src/utils/arrayToMap.ts","../src/utils/isObject.ts","../src/utils/cloneObject.ts","../src/utils/isFileList.ts","../src/utils/isPlainObject.ts","../src/utils/deepMerge.ts","../src/utils/filterErrors.ts","../src/utils/stringToPath.ts","../src/utils/compact.ts","../src/utils/get.ts","../src/utils/isUndefined.ts","../src/utils/getIsDirty.ts","../src/utils/getPath.ts","../src/utils/isFunction.ts","../src/utils/isAsyncFunction.ts","../src/utils/isEmptyObject.ts","../src/utils/isFieldArray.ts","../src/utils/isSelectMultiple.ts","../src/utils/parseState.ts","../src/utils/set.ts","../src/utils/setValuesAsTrue.ts","../src/utils/unset.ts","../src/hooks/useState.ts","../src/useFormState.ts","../src/useControlled.ts","../src/utils/isFieldElement.ts","../src/useFieldArray.ts","../src/useForm.ts","../src/utils/isCheckboxInput.ts","../src/utils/isRadioInput.ts","../src/utils/isSelectOne.ts","../src/utils/isInputElement.ts","../src/utils/isNumberInput.ts","../src/utils/isRangeInput.ts","../src/utils/isFileInput.ts","../src/utils/runWithLowPriority.ts","../src/useFormMethods.ts"],"sourcesContent":["var has = Object.prototype.hasOwnProperty;\n\nexport function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import { Methods, ObjMap } from \"./types\";\n\nlet one: Methods | undefined;\nconst all: ObjMap<Methods> = {};\n\nexport const get = (id?: string): Methods => (id ? all[id] : (one as Methods));\n\nexport const set = (id: string | undefined, methods: Methods): void => {\n  if (id) {\n    all[id] = methods;\n  } else {\n    one = methods;\n  }\n};\n\nexport const remove = (id?: string): void => {\n  if (id) {\n    delete all[id];\n  } else {\n    one = undefined;\n  }\n};\n","import { MutableRefObject, useRef } from \"react\";\n\nexport default <T>(val: T): MutableRefObject<T> => {\n  const ref = useRef(val);\n  ref.current = val;\n  return ref;\n};\n","import { ObjMap } from \"../types\";\n\nexport default (arr: any[], map: Record<string, string> = {}): ObjMap =>\n  arr.reduce((obj, key) => {\n    obj[map[key] || key] = true;\n    return obj;\n  }, {});\n","export default (value: unknown): value is Object =>\n  value !== null && typeof value === \"object\";\n","import isFileList from \"./isFileList\";\nimport isObject from \"./isObject\";\n\nconst cloneObject = (object: unknown): any => {\n  if (object instanceof Event) throw new Error(\"Unable to clone event.\");\n\n  if (!isObject(object) || isFileList(object)) return object;\n\n  if (object instanceof Date) return new Date(object.getTime());\n\n  if (Array.isArray(object)) return object.map((val) => cloneObject(val));\n\n  return Object.keys(object).reduce((obj: Record<string, any>, key) => {\n    obj[key] = cloneObject((object as Record<string, any>)[key]);\n    return obj;\n  }, {});\n};\n\nexport default cloneObject;\n","export default (value: unknown): value is FileList => value instanceof FileList;\n","import isObject from \"./isObject\";\n\nexport default (value: unknown): value is Object =>\n  !Array.isArray(value) && !(value instanceof Date) && isObject(value);\n","import isPlainObject from \"./isPlainObject\";\n\nconst deepMerge = (...objects: any[]): any =>\n  objects.reduce((prev, obj) => {\n    Object.keys(obj).forEach((key) => {\n      const prevValue = prev[key];\n      const currValue = obj[key];\n\n      if (Array.isArray(prevValue) && Array.isArray(currValue)) {\n        prev[key] = [...prevValue, ...currValue];\n      } else if (isPlainObject(prevValue) && isPlainObject(currValue)) {\n        prev[key] = deepMerge(prevValue, currValue);\n      } else {\n        prev[key] = currValue;\n      }\n    });\n\n    return prev;\n  }, {});\n\nexport default deepMerge;\n","import { ObjMap } from \"../types\";\nimport isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\n\nconst filterErrors = (error: unknown, touched: unknown): any => {\n  if (!isPlainObject(error)) return touched ? error : undefined;\n\n  return Object.keys(error).reduce((obj: ObjMap<any>, key) => {\n    const nextErrors = filterErrors(\n      (error as ObjMap<any>)[key],\n      (touched as ObjMap<any>)[key] || false\n    );\n\n    if (!isUndefined(nextErrors)) {\n      obj[key] = nextErrors;\n    } else {\n      delete obj[key];\n    }\n\n    return obj;\n  }, {});\n};\n\nexport default filterErrors;\n","import compact from \"./compact\";\n\nexport default (str: string): string[] => {\n  if (typeof str !== \"string\") throw new TypeError(\"Expected a string.\");\n  if (!str.length) return [];\n\n  return compact(str.split(/[.[\\]]+/));\n};\n","export default (arr: any[]): any[] => arr.filter(Boolean);\n","import isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\nimport stringToPath from \"./stringToPath\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default (object: any, path: string, defaultValue?: unknown): any => {\n  if (!isPlainObject(object) || !path) return defaultValue;\n\n  const value = stringToPath(path).reduce(\n    (obj, key) => (obj || {})[key],\n    object\n  );\n\n  return !isUndefined(value) ? value : defaultValue;\n};\n","export default (value: unknown): value is undefined => value === undefined;\n","import isObject from \"./isObject\";\n\nexport default (dirty: object): boolean => {\n  const search = (dty: object, found: any[] = []) => {\n    for (const val of Object.values(dty)) {\n      if (val === true) {\n        found.push(val);\n        return found;\n      }\n\n      if (isObject(val)) search(val, found);\n    }\n\n    return found;\n  };\n\n  return !!search(dirty).length;\n};\n","export default (path: string): string =>\n  ![\n    \"values\",\n    \"touched\",\n    \"errors\",\n    \"isDirty\",\n    \"dirty\",\n    \"isValidating\",\n    \"isValid\",\n    \"isSubmitting\",\n    \"isSubmitted\",\n    \"submitCount\",\n  ].some((key) => path.startsWith(key))\n    ? `values.${path}`\n    : path;\n","export default (value: unknown): value is Function =>\n  typeof value === \"function\";\n","import isFunction from \"./isFunction\";\n\nexport default (value: unknown): value is Promise<any> =>\n  isFunction(value) && value.constructor.name === \"AsyncFunction\";\n","import { ObjMap } from \"../types\";\nimport isPlainObject from \"./isPlainObject\";\n\nexport default (value: unknown): value is ObjMap<never> =>\n  isPlainObject(value) && !Object.keys(value).length;\n","import { FieldArray } from \"../types\";\n\nexport default (\n  fields: FieldArray,\n  name: string,\n  callback?: (key: string) => void\n): string | void => {\n  let fieldName;\n\n  Object.keys(fields).some((key) => {\n    if (name.startsWith(key)) {\n      fieldName = key;\n      if (callback) callback(key);\n      return true;\n    }\n    return false;\n  });\n\n  return fieldName;\n};\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLSelectElement =>\n  field.type === \"select-multiple\";\n","import { FormState, ObjMap, Path } from \"../types\";\nimport get from \"./get\";\nimport getPath from \"./getPath\";\nimport isPlainObject from \"./isPlainObject\";\n\nexport default (\n  path: Path | undefined,\n  state: FormState,\n  pathHandler = getPath,\n  stateHandler?: (path: string, state: any) => any,\n  isGetState?: boolean\n): any => {\n  if (!path) return isGetState ? state : undefined;\n\n  let parsedState;\n\n  if (Array.isArray(path)) {\n    parsedState = path.map((p) => {\n      p = pathHandler(p);\n      const value = get(state, p);\n      return stateHandler ? stateHandler(p, value) : value;\n    });\n  } else if (isPlainObject(path)) {\n    const paths = path as ObjMap<string>;\n    parsedState = Object.keys(paths).reduce((s: ObjMap<any>, key) => {\n      path = pathHandler(paths[key]);\n      const value = get(state, path);\n      s[key] = stateHandler ? stateHandler(path, value) : value;\n      return s;\n    }, {});\n  } else {\n    path = pathHandler(path);\n    const value = get(state, path);\n    parsedState = stateHandler ? stateHandler(path, value) : value;\n  }\n\n  return parsedState;\n};\n","import cloneObject from \"./cloneObject\";\nimport isPlainObject from \"./isPlainObject\";\nimport stringToPath from \"./stringToPath\";\n\nexport default (\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  object: any,\n  path: string,\n  value: unknown,\n  immutable?: boolean\n): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const newObject = immutable ? cloneObject(object) : object;\n  const segs = stringToPath(path);\n\n  segs.slice(0, -1).reduce((obj, key, idx) => {\n    const nextIsNumber = !Number.isNaN(+segs[idx + 1]);\n    if (\n      (isPlainObject(obj[key]) && !nextIsNumber) ||\n      (Array.isArray(obj[key]) && nextIsNumber)\n    )\n      return obj[key];\n    obj[key] = nextIsNumber ? [] : {};\n    return obj[key];\n  }, newObject)[segs[segs.length - 1] || \"\"] = value;\n\n  return newObject;\n};\n","import isPlainObject from \"./isPlainObject\";\n\nconst setValuesAsTrue = (object: unknown): any => {\n  if (!Array.isArray(object) && !isPlainObject(object)) return true;\n\n  if (Array.isArray(object)) return object.map((val) => setValuesAsTrue(val));\n\n  return Object.keys(object).reduce((obj: Record<string, any>, key) => {\n    obj[key] = setValuesAsTrue((object as Record<string, any>)[key]);\n    return obj;\n  }, {});\n};\n\nexport default setValuesAsTrue;\n","import cloneObject from \"./cloneObject\";\nimport isEmptyObject from \"./isEmptyObject\";\nimport isPlainObject from \"./isPlainObject\";\nimport isUndefined from \"./isUndefined\";\nimport stringToPath from \"./stringToPath\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nconst unset = (object: any, path: string, immutable?: boolean): any => {\n  if (!isPlainObject(object)) throw new TypeError(\"Expected an object.\");\n\n  const refObject = immutable ? cloneObject(object) : object;\n  const newObject = refObject;\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (newObject.hasOwnProperty(path)) {\n    delete newObject[path];\n    return refObject;\n  }\n\n  const segs = stringToPath(path);\n\n  if (!segs.length) return refObject;\n\n  const last = segs.pop() as string;\n  const target = segs.reduce((obj, key) => (obj || {})[key], newObject);\n\n  if (Array.isArray(target)) {\n    let index = +last;\n\n    if (index < target.length - 1) {\n      delete target[index];\n    } else {\n      while (index >= 0) {\n        // @ts-expect-error\n        if (index == last || isUndefined(target[index])) {\n          target.splice(index, 1);\n          index -= 1;\n        } else {\n          break;\n        }\n      }\n    }\n  } else if (isPlainObject(target)) {\n    delete target[last];\n  }\n\n  return isEmptyObject(target) ||\n    (Array.isArray(target) && !target.filter((t) => !isUndefined(t)).length)\n    ? unset(refObject, segs.join(\".\"))\n    : refObject;\n};\n\nexport default unset;\n","import { useReducer, useRef, useCallback } from \"react\";\nimport { dequal } from \"dequal/lite\";\n\nimport {\n  FormState,\n  FormStateReturn,\n  Observer,\n  OnStateChange,\n  SetStateRef,\n} from \"../types\";\nimport useLatest from \"./useLatest\";\nimport { get, getIsDirty, isEmptyObject, set } from \"../utils\";\n\nexport default <V>(\n  initialState: FormState<V>,\n  onChange?: OnStateChange<V>\n): FormStateReturn<V> => {\n  const [, forceUpdate] = useReducer((c) => c + 1, 0);\n  const stateRef = useRef(initialState);\n  const observersRef = useRef<Observer<V>[]>([\n    { usedState: {}, notify: forceUpdate },\n  ]);\n  const onChangeRef = useLatest(onChange || (() => undefined));\n\n  const setStateRef = useCallback<SetStateRef>(\n    (path, value, { fieldPath, shouldSkipUpdate, shouldForceUpdate } = {}) => {\n      const key = path.split(\".\")[0];\n\n      if (!key) {\n        if (!dequal(stateRef.current, value)) {\n          stateRef.current = value;\n          onChangeRef.current(stateRef.current);\n\n          observersRef.current.forEach(\n            ({ usedState, notify }) =>\n              !isEmptyObject(usedState) && notify(stateRef.current)\n          );\n        }\n\n        return;\n      }\n\n      if (\n        (path !== \"values\" && key === \"values\") ||\n        !dequal(get(stateRef.current, path), value)\n      ) {\n        const state = set(stateRef.current, path, value, true);\n        const {\n          errors,\n          dirty,\n          isDirty: prevIsDirty,\n          isValid: prevIsValid,\n          submitCount: prevSubmitCount,\n        } = state;\n        let { submitCount: currSubmitCount } = state;\n        const isDirty = key === \"dirty\" ? getIsDirty(dirty) : prevIsDirty;\n        const isValid = key === \"errors\" ? isEmptyObject(errors) : prevIsValid;\n        const submitCount =\n          key === \"isSubmitting\" && value\n            ? (currSubmitCount += 1)\n            : currSubmitCount;\n\n        stateRef.current = { ...state, isDirty, isValid, submitCount };\n        onChangeRef.current(stateRef.current);\n\n        if (shouldSkipUpdate) return;\n\n        path = fieldPath || path;\n        observersRef.current.forEach(\n          ({ usedState, notify }) =>\n            (shouldForceUpdate ||\n              Object.keys(usedState).some(\n                (k) => path.startsWith(k) || k.startsWith(path)\n              ) ||\n              (usedState.isDirty && isDirty !== prevIsDirty) ||\n              (usedState.isValid && isValid !== prevIsValid) ||\n              (usedState.submitCount && submitCount !== prevSubmitCount)) &&\n            notify(stateRef.current)\n        );\n      }\n    },\n    [onChangeRef]\n  );\n\n  return { stateRef, setStateRef, observersRef };\n};\n","/* eslint-disable react-hooks/rules-of-hooks */\n\nimport { useEffect, useReducer, useRef } from \"react\";\n\nimport {\n  FormStateCallback,\n  FormStateConfig,\n  FormValues,\n  Methods,\n  Observer,\n  Path,\n} from \"./types\";\nimport { get } from \"./shared\";\nimport { invariant, isFunction, parseState } from \"./utils\";\n\nexport default <V extends FormValues = FormValues>(\n  path: Path,\n  configOrCallback: FormStateCallback | FormStateConfig<V>,\n  formId?: string\n): any => {\n  const config = !isFunction(configOrCallback) ? configOrCallback : {};\n  const methods: Methods<V> = get(config?.formId || formId);\n\n  invariant(\n    !methods,\n    `ðŸ’¡ react-cool-form > useFormState: It must work with an \"useForm\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form`\n  );\n\n  const observerRef = useRef<Observer<V>>();\n  const [, forceUpdate] = useReducer((c) => c + 1, 0);\n  const { observersRef, getFormState } = methods;\n  const callback = isFunction(configOrCallback) ? configOrCallback : undefined;\n\n  useEffect(() => {\n    observersRef.current.push(observerRef.current!);\n\n    return () => {\n      observersRef.current = observersRef.current.filter(\n        (o) => o !== observerRef.current\n      );\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return getFormState(path, {\n    ...config,\n    methodName: callback ? \"useFormStateCallback\" : \"useFormState\",\n    callback: (usedState) => {\n      if (!observerRef.current)\n        observerRef.current = {\n          usedState,\n          notify: callback\n            ? (state) => callback(parseState(path, state))\n            : forceUpdate,\n        };\n    },\n  });\n};\n","import { useEffect } from \"react\";\n\nimport {\n  ControlledConfig,\n  ControlledReturn,\n  FormValues,\n  Methods,\n} from \"./types\";\nimport * as shared from \"./shared\";\nimport {\n  get,\n  invariant,\n  isFieldArray,\n  isFieldElement,\n  isUndefined,\n  warn,\n} from \"./utils\";\nimport useFormState from \"./useFormState\";\n\nexport default <V extends FormValues = FormValues>(\n  name: string,\n  {\n    formId,\n    defaultValue,\n    validate,\n    parse,\n    format,\n    errorWithTouched,\n    ...props\n  }: ControlledConfig<V> = {}\n): ControlledReturn => {\n  const methods: Methods<V> = shared.get(formId);\n\n  invariant(\n    !methods,\n    'ðŸ’¡ react-cool-form > useControlled: It must work with an \"useForm\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form'\n  );\n\n  const meta = useFormState(\n    {\n      value: `values.${name}`,\n      error: `errors.${name}`,\n      isTouched: `touched.${name}`,\n      isDirty: `dirty.${name}`,\n    },\n    { formId, errorWithTouched }\n  );\n  const {\n    shouldRemoveField,\n    initialStateRef,\n    fieldArrayRef,\n    controlsRef,\n    fieldValidatorsRef,\n    changedFieldRef,\n    getState,\n    getNodeValue,\n    setDefaultValue,\n    setTouchedMaybeValidate,\n    handleChangeEvent,\n    removeField,\n  } = methods;\n\n  useEffect(\n    () => {\n      const isFieldArr = isFieldArray(fieldArrayRef.current, name);\n      const initialVal = get(initialStateRef.current.values, name);\n\n      if (isUndefined(initialVal)) {\n        if (\n          !isUndefined(defaultValue) &&\n          (!isFieldArr ||\n            !isUndefined(\n              get(initialStateRef.current.values, name.split(\".\")[0])\n            ))\n        ) {\n          setDefaultValue(name, defaultValue);\n        } else if (!isFieldArr) {\n          warn(\n            `ðŸ’¡ react-cool-form > useControlled: Please provide a default value for \"${name}\" field.`\n          );\n        }\n      } else if (isUndefined(getState(name))) {\n        setDefaultValue(name, initialVal);\n      }\n\n      return () => {\n        if (shouldRemoveField(name))\n          removeField(\n            name,\n            !isFieldArr ||\n              isUndefined(\n                // eslint-disable-next-line react-hooks/exhaustive-deps\n                get(initialStateRef.current.values, name.split(\".\")[0])\n              )\n              ? undefined\n              : [\"defaultValue\"]\n          );\n      };\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  controlsRef.current[name] = true;\n  if (validate) fieldValidatorsRef.current[name] = validate;\n\n  const { onChange, onBlur, ...restProps } = props;\n  let value = get(initialStateRef.current.values, name);\n  value = !isUndefined(value) ? value : defaultValue;\n  value = !isUndefined(meta.value) ? meta.value : value;\n  value = (format ? format(value) : value) ?? \"\";\n\n  return [\n    {\n      name,\n      value,\n      onChange: (...event) => {\n        let val;\n\n        if (parse) {\n          val = parse(...event);\n        } else {\n          const e = event[0];\n          val =\n            e?.nativeEvent instanceof Event && isFieldElement(e.target)\n              ? getNodeValue(name)\n              : e;\n        }\n\n        handleChangeEvent(name, val);\n        if (onChange) onChange(...event);\n        changedFieldRef.current = name;\n      },\n      onBlur: (e) => {\n        setTouchedMaybeValidate(name);\n        if (onBlur) onBlur(e);\n        changedFieldRef.current = undefined;\n      },\n      ...restProps,\n    },\n    { error: meta.error, isTouched: !!meta.isTouched, isDirty: !!meta.isDirty },\n  ];\n};\n","import { FieldElement } from \"../types\";\n\nexport default (element: HTMLElement): element is FieldElement =>\n  /INPUT|TEXTAREA|SELECT/.test(element.tagName);\n","import { useCallback, useEffect, useState } from \"react\";\n\nimport {\n  FieldArrayConfig,\n  FieldArrayReturn,\n  FormValues,\n  Insert,\n  Keys,\n  Methods,\n  Move,\n  Push,\n  Remove,\n  StateHandler,\n  Swap,\n} from \"./types\";\nimport * as shared from \"./shared\";\nimport {\n  compact,\n  get,\n  getIsDirty,\n  invariant,\n  isUndefined,\n  set,\n  setValuesAsTrue,\n} from \"./utils\";\n\nexport default <T = any, V extends FormValues = FormValues>(\n  name: string,\n  { formId, defaultValue, validate }: FieldArrayConfig<T, V> = {}\n): FieldArrayReturn<T> => {\n  const methods: Methods<V> = shared.get(formId);\n\n  invariant(\n    !methods,\n    'ðŸ’¡ react-cool-form > useFieldArray: It must work with an \"useForm\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form'\n  );\n\n  const {\n    validateOnChange,\n    shouldRemoveField,\n    initialStateRef,\n    fieldArrayRef,\n    fieldValidatorsRef,\n    getState,\n    setDefaultValue,\n    setNodesOrValues,\n    setStateRef,\n    runValidation,\n    removeField,\n  } = methods;\n\n  const getFields = useCallback(\n    (init = false): string[] => {\n      let fields = getState(name);\n\n      if (init && isUndefined(fields)) fields = defaultValue;\n\n      return Array.isArray(fields)\n        ? fields.map((_, index) => `${name}[${index}]`)\n        : [];\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [getState, name]\n  );\n\n  const [fields, setFields] = useState<string[]>(getFields(true));\n\n  const updateFields = useCallback(() => {\n    setFields(getFields());\n    setNodesOrValues(getState(\"values\"), {\n      shouldSetValues: false,\n      fields: Object.keys(fieldArrayRef.current[name].fields),\n    });\n  }, [fieldArrayRef, getFields, getState, name, setNodesOrValues]);\n\n  useEffect(() => {\n    if (\n      isUndefined(get(initialStateRef.current.values, name)) &&\n      !isUndefined(defaultValue)\n    ) {\n      setDefaultValue(name, defaultValue, true);\n      updateFields();\n    }\n\n    return () => {\n      if (shouldRemoveField(name)) removeField(name);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  if (!fieldArrayRef.current[name])\n    fieldArrayRef.current[name] = {\n      reset: updateFields,\n      fields: {},\n    };\n  if (validate) fieldValidatorsRef.current[name] = validate;\n\n  const setState = useCallback(\n    (\n      handler: StateHandler,\n      {\n        shouldTouched,\n        shouldDirty,\n      }: { shouldTouched?: boolean; shouldDirty?: boolean } = {}\n    ) => {\n      let state = getState();\n\n      ([\"values\", \"touched\", \"errors\", \"dirty\"] as Keys[]).forEach((key) => {\n        const value = state[key][name];\n        const fieldsLength = state.values[name]?.length;\n\n        if (\n          key === \"values\" ||\n          (key === \"touched\" && shouldTouched) ||\n          (key === \"dirty\" && shouldDirty) ||\n          !isUndefined(value)\n        )\n          state = set(\n            state,\n            key,\n            {\n              ...state[key],\n              [name]: handler(\n                Array.isArray(value) ? [...value] : [],\n                key,\n                fieldsLength ? fieldsLength - 1 : 0\n              ),\n            },\n            true\n          );\n      });\n\n      setStateRef(\"\", { ...state, shouldDirty: getIsDirty(state.dirty) });\n      updateFields();\n\n      if (validateOnChange) runValidation(name);\n    },\n    [getState, name, runValidation, setStateRef, updateFields, validateOnChange]\n  );\n\n  const push = useCallback<Push<T>>(\n    (value, { shouldTouched, shouldDirty = true } = {}) => {\n      const handler: StateHandler = (f, type, lastIndex = 0) => {\n        if (type === \"values\") {\n          f.push(value);\n        } else if (\n          (type === \"touched\" && shouldTouched) ||\n          (type === \"dirty\" && shouldDirty)\n        ) {\n          f[lastIndex] = setValuesAsTrue(value);\n        }\n\n        return f;\n      };\n\n      setState(handler, { shouldTouched, shouldDirty });\n    },\n    [setState]\n  );\n\n  const insert = useCallback<Insert<T>>(\n    (index, value, { shouldTouched, shouldDirty = true } = {}) => {\n      const handler: StateHandler = (f, type) => {\n        if (type === \"values\") {\n          f.splice(index, 0, value);\n        } else if (\n          (type === \"touched\" && shouldTouched) ||\n          (type === \"dirty\" && shouldDirty)\n        ) {\n          f[index] = setValuesAsTrue(value);\n        } else if (index < f.length) {\n          f.splice(index, 0, undefined);\n        }\n\n        return f;\n      };\n\n      setState(handler, { shouldTouched, shouldDirty });\n    },\n    [setState]\n  );\n\n  const remove = useCallback<Remove<T>>(\n    (index) => {\n      const handler: StateHandler = (f) => {\n        f.splice(index, 1);\n        return compact(f).length ? f : [];\n      };\n      const value = (getState(name) || [])[index];\n\n      setState(handler);\n\n      return value;\n    },\n    [getState, name, setState]\n  );\n\n  const swap = useCallback<Swap>(\n    (indexA, indexB) => {\n      const handler: StateHandler = (f) => {\n        [f[indexA], f[indexB]] = [f[indexB], f[indexA]];\n        return f;\n      };\n\n      setState(handler);\n    },\n    [setState]\n  );\n\n  const move = useCallback<Move>(\n    (from, to) => {\n      const handler: StateHandler = (f) => {\n        f.splice(to, 0, f.splice(from, 1)[0]);\n        return f;\n      };\n\n      setState(handler);\n    },\n    [setState]\n  );\n\n  return [fields, { push, insert, remove, swap, move }];\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport { useCallback, useEffect, useRef } from \"react\";\nimport { dequal } from \"dequal/lite\";\n\nimport * as shared from \"./shared\";\nimport {\n  ClearErrors,\n  FieldArray,\n  FieldElement,\n  Fields,\n  FieldValidator,\n  Focus,\n  FormConfig,\n  FormErrors,\n  FormMethods,\n  FormState,\n  FormValues,\n  GetFormState,\n  GetNodeValue,\n  GetState,\n  HandleChangeEvent,\n  Handlers,\n  ObjMap,\n  Parsers,\n  RegisterField,\n  RegisterForm,\n  RemoveField,\n  Reset,\n  RunValidation,\n  SetDefaultValue,\n  SetDirty,\n  SetError,\n  SetNodesOrValues,\n  SetTouched,\n  SetTouchedMaybeValidate,\n  SetValue,\n  ShouldRemoveField,\n  Submit,\n  Use,\n} from \"./types\";\nimport { useLatest, useState } from \"./hooks\";\nimport {\n  arrayToMap,\n  compact,\n  deepMerge,\n  filterErrors,\n  get,\n  getPath,\n  isAsyncFunction,\n  isCheckboxInput,\n  isEmptyObject,\n  isFieldArray,\n  isFieldElement,\n  isFileInput,\n  isFileList,\n  isFunction,\n  isInputElement,\n  isNumberInput,\n  isPlainObject,\n  isRadioInput,\n  isRangeInput,\n  isSelectMultiple,\n  isSelectOne,\n  isUndefined,\n  parseState,\n  runWithLowPriority,\n  set,\n  unset,\n  warn,\n} from \"./utils\";\n\nexport default <V extends FormValues = FormValues>({\n  id,\n  defaultValues = {} as V,\n  validate,\n  validateOnChange = true,\n  validateOnBlur = true,\n  focusOnError = true,\n  removeOnUnmounted = true,\n  builtInValidationMode = \"message\",\n  excludeFields = [],\n  onReset,\n  onSubmit,\n  onError,\n  onStateChange,\n}: FormConfig<V> = {}): FormMethods<V> => {\n  const handlersRef = useRef<Handlers>({});\n  const mutationObserverRef = useRef<MutationObserver>();\n  const formRef = useRef<HTMLElement>();\n  const fieldsRef = useRef<Fields>(new Map());\n  const fieldParsersRef = useRef<Parsers>({});\n  const fieldArrayRef = useRef<FieldArray>({});\n  const controlsRef = useRef<ObjMap>({});\n  const formValidatorRef = useLatest(validate);\n  const fieldValidatorsRef = useRef<ObjMap<FieldValidator<V>>>({});\n  const changedFieldRef = useRef<string>();\n  const excludeFieldsRef = useRef<ObjMap>(arrayToMap(excludeFields));\n  const onResetRef = useLatest(onReset || (() => undefined));\n  const onSubmitRef = useLatest(onSubmit || (() => undefined));\n  const onErrorRef = useLatest(onError || (() => undefined));\n  const hasWarnValues = useRef(false);\n  const initialStateRef = useRef<FormState<V>>({\n    values: defaultValues,\n    touched: {},\n    errors: {},\n    isDirty: false,\n    dirty: {},\n    isValidating: false,\n    isValid: true,\n    isSubmitting: false,\n    isSubmitted: false,\n    submitCount: 0,\n  });\n  const { stateRef, setStateRef, observersRef } = useState<V>(\n    { ...initialStateRef.current },\n    onStateChange\n  );\n\n  const handleUnset = useCallback(\n    (\n      path: string,\n      options?: { shouldSkipUpdate?: boolean; shouldForceUpdate?: boolean }\n    ) => {\n      const segs = path.split(\".\");\n      const k = segs.shift() as string;\n      setStateRef(\n        k,\n        unset(stateRef.current[k as keyof FormState<V>], segs.join(\".\"), true),\n        { fieldPath: path, ...options }\n      );\n    },\n    [setStateRef, stateRef]\n  );\n\n  const handleFocus = useCallback((name: string) => {\n    const field =\n      fieldsRef.current.get(name)?.field ||\n      fieldsRef.current.get(\n        Array.from(fieldsRef.current.keys()).find((n) => n.startsWith(name)) ||\n          \"\"\n      )?.field;\n\n    if (field && isFunction(field.focus)) field.focus();\n  }, []);\n\n  const getFields = useCallback(\n    (form: HTMLElement) =>\n      Array.from(form.querySelectorAll(\"input,textarea,select\"))\n        .filter((element) => {\n          const field = element as FieldElement;\n          const {\n            type,\n            name,\n            id: fieldId,\n            classList,\n            dataset: { rcfExclude },\n          } = field;\n          const { current: exclude } = excludeFieldsRef;\n\n          if (\n            /button|image|submit|reset/.test(type) ||\n            (fieldId && exclude[`#${fieldId}`]) ||\n            Array.from(classList).find((n) => exclude[`.${n}`])\n          )\n            return false;\n\n          if (rcfExclude !== \"true\" && !name) {\n            warn(\n              'ðŸ’¡ react-cool-form > field: Missing \"name\" attribute. Do you want to exclude the field? See: https://react-cool-form.netlify.app/docs/api-reference/use-form/#excludefields'\n            );\n            return false;\n          }\n\n          return (\n            controlsRef.current[name] ||\n            (rcfExclude !== \"true\" && !exclude[name])\n          );\n        })\n        .reduce((acc, elm) => {\n          const field = elm as FieldElement;\n          const { name } = field;\n          const fieldArrayName = isFieldArray(fieldArrayRef.current, name);\n\n          if (fieldArrayName)\n            fieldArrayRef.current[fieldArrayName].fields[name] = true;\n\n          acc.set(name, {\n            ...acc.get(name),\n            field: acc.get(name)?.field || field,\n          });\n\n          if (isCheckboxInput(field) || isRadioInput(field)) {\n            acc.get(name).options = acc.get(name).options\n              ? [...acc.get(name).options, field]\n              : [field];\n          } else if (isSelectOne(field) || isSelectMultiple(field)) {\n            acc.get(name).options = Array.from(field.options);\n          }\n\n          return acc;\n        }, new Map()),\n    []\n  );\n\n  const getNodeValue = useCallback<GetNodeValue>(\n    (name, fields = fieldsRef.current) => {\n      if (!fields.has(name)) return undefined;\n\n      const { field, options } = fields.get(name)!;\n\n      if (isInputElement(field)) {\n        if (fieldParsersRef.current[name]?.valueAsNumber)\n          return field.valueAsNumber;\n        if (fieldParsersRef.current[name]?.valueAsDate)\n          return field.valueAsDate;\n      }\n\n      if (isNumberInput(field) || isRangeInput(field))\n        return field.valueAsNumber || \"\";\n\n      if (isCheckboxInput(field)) {\n        const checkboxes = options as HTMLInputElement[];\n\n        if (checkboxes.length > 1)\n          return checkboxes.filter((c) => c.checked).map((c) => c.value);\n\n        const checkbox = checkboxes[0];\n\n        if (checkbox.hasAttribute(\"value\") && checkbox.value)\n          return checkbox.checked ? [checkbox.value] : [];\n\n        return checkbox.checked;\n      }\n\n      if (isRadioInput(field))\n        return (\n          (options as HTMLInputElement[]).find((radio) => radio.checked)\n            ?.value || \"\"\n        );\n\n      if (isSelectMultiple(field))\n        return (options as HTMLOptionElement[])\n          .filter((option) => option.selected)\n          .map((option) => option.value);\n\n      if (isFileInput(field)) return field.files;\n\n      return field.value;\n    },\n    []\n  );\n\n  const setNodeValue = useCallback(\n    (name: string, value: any, fields: Fields = fieldsRef.current) => {\n      if (!fields.has(name) || controlsRef.current[name]) return;\n\n      const { field, options } = fields.get(name)!;\n\n      if (isCheckboxInput(field)) {\n        const checkboxes = options as HTMLInputElement[];\n\n        if (checkboxes.length > 1) {\n          checkboxes.forEach((checkbox) => {\n            checkbox.checked = Array.isArray(value)\n              ? value.includes(checkbox.value)\n              : !!value;\n          });\n        } else {\n          checkboxes[0].checked = !!value;\n        }\n      } else if (isRadioInput(field)) {\n        (options as HTMLInputElement[]).forEach((radio) => {\n          radio.checked = radio.value === value;\n        });\n      } else if (isSelectMultiple(field) && Array.isArray(value)) {\n        (options as HTMLOptionElement[]).forEach((option) => {\n          option.selected = !!value.includes(option.value);\n        });\n      } else if (isFileInput(field)) {\n        if (isFileList(value)) field.files = value;\n        if (!value) field.value = \"\";\n      } else {\n        field.value = value ?? \"\";\n      }\n    },\n    []\n  );\n\n  const setDefaultValue = useCallback<SetDefaultValue>(\n    (\n      name,\n      value,\n      shouldUpdateDefaultValue = !isFieldArray(fieldArrayRef.current, name) ||\n        !isUndefined(get(initialStateRef.current.values, name.split(\".\")[0]))\n    ) => {\n      if (shouldUpdateDefaultValue)\n        initialStateRef.current.values = set(\n          initialStateRef.current.values,\n          name,\n          value,\n          true\n        );\n\n      if (!dequal(get(stateRef.current.values, name), value))\n        setStateRef(`values.${name}`, value, { shouldSkipUpdate: true });\n    },\n    [setStateRef, stateRef]\n  );\n\n  const setNodesOrValues = useCallback<SetNodesOrValues<V>>(\n    (\n      values,\n      {\n        shouldSetValues = true,\n        fields = Array.from(fieldsRef.current.keys()),\n      } = {}\n    ) =>\n      fields.forEach((name) => {\n        if (controlsRef.current[name]) return;\n\n        const value = get(values, name);\n\n        if (!isUndefined(value)) setNodeValue(name, value);\n\n        if (shouldSetValues)\n          setDefaultValue(\n            name,\n            !isUndefined(value) ? value : getNodeValue(name)\n          );\n      }),\n    [getNodeValue, setDefaultValue, setNodeValue]\n  );\n\n  const setError = useCallback<SetError>(\n    (name, error) => {\n      error = isFunction(error)\n        ? error(get(stateRef.current.errors, name))\n        : error;\n\n      if (error) {\n        setStateRef(`errors.${name}`, error);\n      } else {\n        handleUnset(`errors.${name}`);\n      }\n    },\n    [handleUnset, setStateRef, stateRef]\n  );\n\n  const clearErrors = useCallback<ClearErrors>(\n    (name) => {\n      if (!name) {\n        setStateRef(\"errors\", {});\n      } else if (Array.isArray(name)) {\n        name.forEach((n) => setError(n));\n      } else {\n        setError(name);\n      }\n    },\n    [setError, setStateRef]\n  );\n\n  const runBuiltInValidation = useCallback(\n    (name: string) => {\n      if (builtInValidationMode === false || !fieldsRef.current.has(name))\n        return undefined;\n\n      const {\n        field: { validity, validationMessage },\n      } = fieldsRef.current.get(name)!;\n\n      if (builtInValidationMode === \"state\")\n        for (const k in validity)\n          if (k !== \"valid\" && validity[k as keyof ValidityState]) return k;\n\n      return validationMessage;\n    },\n    [builtInValidationMode]\n  );\n\n  const runAllBuiltInValidation = useCallback(() => {\n    if (builtInValidationMode === false) return {};\n\n    return Array.from(fieldsRef.current.keys()).reduce((errors, name) => {\n      const error = runBuiltInValidation(name);\n      errors = { ...errors, ...(error ? set(errors, name, error) : {}) };\n      return errors;\n    }, {});\n  }, [builtInValidationMode, runBuiltInValidation]);\n\n  const runFieldValidation = useCallback(\n    async (name: string): Promise<any> => {\n      const value = get(stateRef.current.values, name);\n\n      if (!fieldValidatorsRef.current[name] || isUndefined(value))\n        return undefined;\n\n      try {\n        const error = await fieldValidatorsRef.current[name](\n          value,\n          stateRef.current.values\n        );\n\n        return error;\n      } catch (exception) {\n        warn(`ðŸ’¡ react-cool-form > validate ${name}: `, exception);\n        throw exception;\n      }\n    },\n    [stateRef]\n  );\n\n  const runAllFieldsValidation = useCallback((): Promise<FormErrors<V>> => {\n    const promises = Object.keys(fieldValidatorsRef.current).map((name) =>\n      runFieldValidation(name)\n    );\n\n    return Promise.all(promises).then((errors) =>\n      Object.keys(fieldValidatorsRef.current).reduce((acc, cur, idx) => {\n        acc = { ...acc, ...(errors[idx] ? set(acc, cur, errors[idx]) : {}) };\n        return acc;\n      }, {})\n    );\n  }, [runFieldValidation]);\n\n  const runFormValidation = useCallback(\n    async (name?: string): Promise<any> => {\n      if (!formValidatorRef.current) return name ? undefined : {};\n\n      try {\n        const errors = await formValidatorRef.current(stateRef.current.values);\n\n        if (name) return get(errors, name);\n\n        return isPlainObject(errors) ? errors : {};\n      } catch (exception) {\n        warn(`ðŸ’¡ react-cool-form > validate form: `, exception);\n        throw exception;\n      }\n    },\n    [formValidatorRef, stateRef]\n  );\n\n  const validateField = useCallback(\n    async (name: string) => {\n      const hasAsyncValidator =\n        isAsyncFunction(formValidatorRef.current) ||\n        isAsyncFunction(fieldValidatorsRef.current[name]);\n\n      if (hasAsyncValidator) setStateRef(\"isValidating\", true);\n\n      try {\n        const error =\n          (await runFormValidation(name)) ||\n          (await runFieldValidation(name)) ||\n          runBuiltInValidation(name);\n\n        setError(name, error);\n        if (hasAsyncValidator) setStateRef(\"isValidating\", false);\n\n        return error;\n      } catch (exception) {\n        return exception;\n      }\n    },\n    [\n      formValidatorRef,\n      runBuiltInValidation,\n      runFieldValidation,\n      runFormValidation,\n      setError,\n      setStateRef,\n    ]\n  );\n\n  const validateFieldWithLowPriority = useCallback<typeof validateField>(\n    (name) => runWithLowPriority(() => validateField(name)),\n    [validateField]\n  );\n\n  const validateForm = useCallback((): Promise<FormErrors<V>> => {\n    setStateRef(\"isValidating\", true);\n\n    return Promise.all([\n      runAllBuiltInValidation(),\n      runAllFieldsValidation(),\n      runFormValidation(),\n    ]).then((errors) => {\n      const errs = deepMerge(...errors);\n\n      setStateRef(\"errors\", errs);\n      setStateRef(\"isValidating\", false);\n\n      return errs;\n    });\n  }, [\n    runAllBuiltInValidation,\n    runAllFieldsValidation,\n    runFormValidation,\n    setStateRef,\n  ]);\n\n  const runValidation = useCallback<RunValidation>(\n    (name, { shouldFocus = focusOnError } = {}) => {\n      let names: string[] = [];\n\n      if (shouldFocus) {\n        names = Array.isArray(shouldFocus)\n          ? shouldFocus\n          : Array.from(fieldsRef.current.keys());\n        names = isFunction(shouldFocus) ? shouldFocus(names) : names;\n      }\n\n      if (!name)\n        return validateForm().then((errors) => {\n          if (shouldFocus) {\n            const fieldName = names.find((n) => get(errors, n));\n            if (fieldName) handleFocus(fieldName);\n          }\n\n          return isEmptyObject(errors);\n        });\n\n      if (Array.isArray(name))\n        return Promise.all(name.map((n) => validateField(n))).then((errors) => {\n          if (shouldFocus) {\n            const fieldName = names.find((n) => !!errors[name.indexOf(n)]);\n            if (fieldName) handleFocus(fieldName);\n          }\n\n          return !compact(errors).length;\n        });\n\n      return validateField(name).then((error) => {\n        if (shouldFocus && error && names.includes(name)) handleFocus(name);\n\n        return !error;\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [handleFocus, validateField, validateForm]\n  );\n\n  const getFormState = useCallback<GetFormState<V>>(\n    (\n      path,\n      {\n        errorWithTouched,\n        defaultValues: dfValues = {},\n        methodName = \"getState\",\n        callback,\n      } = {}\n    ) => {\n      const usedState: ObjMap = {};\n      const state = parseState(\n        path,\n        stateRef.current,\n        (p) => {\n          p = getPath(p);\n\n          if (methodName !== \"getState\") {\n            if (\n              p === \"values\" &&\n              methodName !== \"useFormStateCallback\" &&\n              !hasWarnValues.current\n            ) {\n              warn(\n                `ðŸ’¡ react-cool-form > ${methodName}: Getting \"values\" alone might cause unnecessary re-renders. If you know what you're doing, just ignore this warning. See: https://react-cool-form.netlify.app/docs/getting-started/form-state#best-practices`\n              );\n              hasWarnValues.current = true;\n            }\n\n            usedState[p] = true;\n          }\n\n          return p;\n        },\n        (p, v) => {\n          if (methodName === \"getState\") return v;\n\n          if (p.startsWith(\"values\")) {\n            if (!isUndefined(v)) return v;\n\n            p = p.replace(\"values.\", \"\");\n            v = get(initialStateRef.current, p);\n\n            return !isUndefined(v) ? v : get(dfValues, p);\n          }\n\n          if (!errorWithTouched || !p.startsWith(\"errors\")) return v;\n\n          p = p.replace(\"errors\", \"touched\");\n          usedState[p] = true;\n\n          return filterErrors(v, get(stateRef.current, p));\n        },\n        methodName === \"getState\"\n      );\n\n      if (callback) callback(usedState);\n\n      return state;\n    },\n    [stateRef]\n  );\n\n  const focus = useCallback<Focus>(\n    (name, delay) => {\n      if (!isUndefined(delay)) {\n        setTimeout(() => handleFocus(name), delay);\n      } else {\n        handleFocus(name);\n      }\n    },\n    [handleFocus]\n  );\n\n  const use = useCallback<Use<V>>(\n    (path, { errorWithTouched, defaultValues: dfValues } = {}) =>\n      getFormState(path, {\n        errorWithTouched,\n        defaultValues: dfValues,\n        methodName: \"use\",\n        callback: (usedState) => {\n          observersRef.current[0].usedState = {\n            ...observersRef.current[0].usedState,\n            ...usedState,\n          };\n        },\n      }),\n    [getFormState, observersRef]\n  );\n\n  const getState = useCallback<GetState>(\n    (path) => getFormState(path),\n    [getFormState]\n  );\n\n  const setTouched = useCallback<SetTouched>(\n    (name, isTouched = true, { shouldValidate = validateOnBlur } = {}) => {\n      if (isTouched) {\n        setStateRef(`touched.${name}`, true);\n      } else {\n        handleUnset(`touched.${name}`);\n      }\n\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [handleUnset, setStateRef, validateFieldWithLowPriority, validateOnBlur]\n  );\n\n  const setTouchedMaybeValidate = useCallback<SetTouchedMaybeValidate>(\n    (name) =>\n      setTouched(name, true, {\n        shouldValidate: validateOnChange\n          ? name !== changedFieldRef.current\n          : undefined,\n      }),\n    [setTouched, validateOnChange]\n  );\n\n  const setDirty = useCallback<SetDirty>(\n    (name, isDirty = true) => {\n      if (isDirty) {\n        setStateRef(`dirty.${name}`, true);\n      } else {\n        handleUnset(`dirty.${name}`);\n      }\n    },\n    [handleUnset, setStateRef]\n  );\n\n  const setDirtyIfNeeded = useCallback(\n    (name: string) =>\n      setDirty(\n        name,\n        !dequal(\n          get(stateRef.current.values, name),\n          get(initialStateRef.current.values, name)\n        )\n      ),\n    [setDirty, stateRef]\n  );\n\n  const setValue = useCallback<SetValue>(\n    (\n      name,\n      value,\n      {\n        shouldValidate = validateOnChange,\n        shouldTouched = true,\n        shouldDirty = true,\n      } = {}\n    ) => {\n      value = isFunction(value)\n        ? value(get(stateRef.current.values, name))\n        : value;\n\n      if (!isUndefined(value)) {\n        setStateRef(`values.${name}`, value);\n      } else {\n        handleUnset(`values.${name}`);\n      }\n      setNodeValue(name, value);\n\n      isFieldArray(fieldArrayRef.current, name, (key) =>\n        fieldArrayRef.current[key].reset()\n      );\n\n      if (shouldTouched) setTouched(name, true, { shouldValidate: false });\n      if (shouldDirty) setDirtyIfNeeded(name);\n      if (shouldValidate) validateFieldWithLowPriority(name);\n    },\n    [\n      handleUnset,\n      setDirtyIfNeeded,\n      setNodeValue,\n      setStateRef,\n      setTouched,\n      stateRef,\n      validateFieldWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const getOptions = useCallback(\n    () => ({\n      getState,\n      setValue,\n      setTouched,\n      setDirty,\n      setError,\n      clearErrors,\n      runValidation,\n      removeField,\n      focus,\n      reset,\n      submit,\n    }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  const reset: Reset<V> = useCallback(\n    (values, exclude, e) => {\n      if (e?.preventDefault) e.preventDefault();\n      if (e?.stopPropagation) e.stopPropagation();\n\n      const state = { ...stateRef.current };\n      const skip = arrayToMap(exclude || []);\n\n      Object.keys(state).forEach((key) => {\n        if (skip[key]) return;\n\n        if (key === \"values\") {\n          const nextValues =\n            (isFunction(values) ? values(stateRef.current.values) : values) ||\n            initialStateRef.current.values;\n\n          state[key] = nextValues;\n          initialStateRef.current.values = nextValues;\n          setNodesOrValues(nextValues, {\n            shouldSetValues: false,\n            fields: Array.from(fieldsRef.current.keys()).filter(\n              (name) => !isFieldArray(fieldArrayRef.current, name)\n            ),\n          });\n        } else {\n          // @ts-expect-error\n          state[key] = initialStateRef.current[key];\n        }\n      });\n\n      setStateRef(\"\", state);\n      onResetRef.current(state.values, getOptions(), e);\n\n      Object.values(fieldArrayRef.current).forEach((field) => field.reset());\n    },\n    [getOptions, onResetRef, setNodesOrValues, setStateRef, stateRef]\n  );\n\n  const submit: Submit<V> = useCallback(\n    async (e) => {\n      if (e?.preventDefault) e.preventDefault();\n      if (e?.stopPropagation) e.stopPropagation();\n\n      const nextTouched = [\n        ...Array.from(fieldsRef.current.keys()),\n        ...Object.keys(controlsRef.current),\n      ].reduce((touched, name) => {\n        touched = set(touched, name, true, true);\n        return touched;\n      }, stateRef.current.touched);\n\n      setStateRef(\"touched\", nextTouched);\n      setStateRef(\"isSubmitted\", false);\n      setStateRef(\"isSubmitting\", true);\n\n      try {\n        const isValid = await runValidation();\n\n        if (!isValid) {\n          const { errors } = stateRef.current;\n          onErrorRef.current(errors, getOptions(), e);\n          return { errors };\n        }\n\n        await onSubmitRef.current(stateRef.current.values, getOptions(), e);\n        setStateRef(\"isSubmitted\", true);\n\n        return { values: stateRef.current.values };\n      } catch (exception) {\n        warn(`ðŸ’¡ react-cool-form > submit: `, exception);\n        throw exception;\n      } finally {\n        setStateRef(\"isSubmitting\", false);\n      }\n    },\n    [getOptions, onErrorRef, onSubmitRef, runValidation, setStateRef, stateRef]\n  );\n\n  const handleChangeEvent = useCallback<HandleChangeEvent>(\n    (name, value) => {\n      setStateRef(`values.${name}`, value);\n      setDirtyIfNeeded(name);\n\n      if (validateOnChange) validateFieldWithLowPriority(name);\n    },\n    [\n      setDirtyIfNeeded,\n      setStateRef,\n      validateFieldWithLowPriority,\n      validateOnChange,\n    ]\n  );\n\n  const shouldRemoveField = useCallback<ShouldRemoveField>(\n    (name) => {\n      if (!removeOnUnmounted) return false;\n\n      let names = Array.isArray(removeOnUnmounted)\n        ? removeOnUnmounted\n        : [\n            ...Array.from(fieldsRef.current.keys()),\n            ...Object.keys(controlsRef.current),\n            ...Object.keys(fieldArrayRef.current),\n          ];\n      names = isFunction(removeOnUnmounted) ? removeOnUnmounted(names) : names;\n\n      return names.includes(name);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  const removeField = useCallback<RemoveField>(\n    (name, exclude) => {\n      const { defaultValue, ...rest } = arrayToMap(exclude || [], {\n        value: \"values\",\n        error: \"errors\",\n      });\n\n      if (!defaultValue)\n        initialStateRef.current.values = unset(\n          initialStateRef.current.values,\n          name,\n          true\n        );\n\n      [\"values\", \"touched\", \"dirty\", \"errors\"].forEach((key, idx, arr) => {\n        const shouldForceUpdate = idx === arr.length - 1;\n\n        if (\n          !rest[key] &&\n          !isUndefined(get(stateRef.current[key as keyof FormState<V>], name))\n        )\n          handleUnset(`${key}.${name}`, {\n            shouldSkipUpdate: !shouldForceUpdate,\n            shouldForceUpdate,\n          });\n      });\n\n      delete fieldParsersRef.current[name];\n      delete fieldValidatorsRef.current[name];\n      delete fieldArrayRef.current[name];\n      delete controlsRef.current[name];\n\n      if (fieldsRef.current.has(name)) fieldsRef.current.delete(name);\n    },\n    [handleUnset, stateRef]\n  );\n\n  const registerForm = useCallback<RegisterForm>(\n    (el) => {\n      if (!el) return;\n\n      formRef.current = el;\n      const form = formRef.current;\n\n      fieldsRef.current = getFields(form);\n      setNodesOrValues(initialStateRef.current.values);\n\n      handlersRef.current.change = ({ target }: Event) => {\n        const { name } = target as FieldElement;\n\n        if (fieldsRef.current.has(name) && !controlsRef.current[name]) {\n          const parse = fieldParsersRef.current[name]?.parse;\n          const value = getNodeValue(name);\n\n          handleChangeEvent(name, parse ? parse(value) : value);\n          changedFieldRef.current = name;\n        }\n      };\n\n      handlersRef.current.blur = ({ target }: Event) => {\n        if (!isFieldElement(target as HTMLElement)) return;\n\n        const { name } = target as FieldElement;\n\n        if (fieldsRef.current.has(name) && !controlsRef.current[name]) {\n          setTouchedMaybeValidate(name);\n          changedFieldRef.current = undefined;\n        }\n      };\n\n      handlersRef.current.submit = (e: Event) => submit(e as any);\n\n      handlersRef.current.reset = (e: Event) => reset(null, null, e as any);\n\n      form.addEventListener(\"input\", handlersRef.current.change);\n      form.addEventListener(\"focusout\", handlersRef.current.blur);\n      form.addEventListener(\"submit\", handlersRef.current.submit);\n      form.addEventListener(\"reset\", handlersRef.current.reset);\n\n      mutationObserverRef.current = new MutationObserver(([{ type }]) => {\n        if (type !== \"childList\") return;\n\n        const fields = getFields(form);\n        let { values } = initialStateRef.current;\n\n        fieldsRef.current.forEach((_, name) => {\n          if (!shouldRemoveField(name)) return;\n          if (controlsRef.current[name]) return;\n\n          if (!fields.has(name)) {\n            removeField(\n              name,\n              !isFieldArray(fieldArrayRef.current, name) ||\n                isUndefined(\n                  get(initialStateRef.current.values, name.split(\".\")[0])\n                )\n                ? undefined\n                : [\"defaultValue\"]\n            );\n\n            return;\n          }\n\n          const currOptions = fieldsRef.current.get(name)?.options\n            ?.length as number;\n          const nextOptions = fields.get(name).options?.length as number;\n\n          if (currOptions > nextOptions) {\n            setStateRef(`values.${name}`, getNodeValue(name, fields), {\n              shouldSkipUpdate: true,\n            });\n          } else if (currOptions < nextOptions) {\n            setNodeValue(name, get(values, name), fields);\n          }\n        });\n\n        const addedNodes: string[] = [];\n\n        fields.forEach((_, name) => {\n          if (fieldsRef.current.has(name) || controlsRef.current[name]) return;\n\n          const value = get(stateRef.current.values, name);\n          if (!isUndefined(value)) values = set(values, name, value, true);\n\n          addedNodes.push(name);\n        });\n\n        fieldsRef.current = fields;\n        if (addedNodes.length) setNodesOrValues(values, { fields: addedNodes });\n      });\n\n      mutationObserverRef.current.observe(form, {\n        childList: true,\n        subtree: true,\n      });\n    },\n    [\n      getFields,\n      getNodeValue,\n      handleChangeEvent,\n      removeField,\n      reset,\n      setNodeValue,\n      setNodesOrValues,\n      setStateRef,\n      setTouchedMaybeValidate,\n      shouldRemoveField,\n      stateRef,\n      submit,\n    ]\n  );\n\n  const registerField = useCallback<RegisterField<V>>(\n    (value) => (field) => {\n      if (\n        !field?.name ||\n        controlsRef.current[field.name] ||\n        excludeFieldsRef.current[field.name]\n      )\n        return;\n\n      if (isFunction(value)) {\n        fieldValidatorsRef.current[field.name] = value;\n        return;\n      }\n\n      const { validate: validator, ...parsers } = value;\n\n      if (validator) fieldValidatorsRef.current[field.name] = validator;\n      fieldParsersRef.current[field.name] = parsers;\n    },\n    []\n  );\n\n  shared.set(id, {\n    validateOnChange,\n    shouldRemoveField,\n    initialStateRef,\n    fieldArrayRef,\n    controlsRef,\n    observersRef,\n    fieldValidatorsRef,\n    changedFieldRef,\n    setStateRef,\n    getNodeValue,\n    getFormState,\n    setDefaultValue,\n    setNodesOrValues,\n    setTouchedMaybeValidate,\n    handleChangeEvent,\n    removeField,\n    form: registerForm,\n    field: registerField,\n    focus,\n    use,\n    getState,\n    setValue,\n    setTouched,\n    setDirty,\n    setError,\n    clearErrors,\n    runValidation,\n    reset,\n    submit,\n  });\n\n  useEffect(\n    () => () => {\n      if (formRef.current) {\n        const handlers = handlersRef.current as Required<Handlers>;\n\n        formRef.current.removeEventListener(\"input\", handlers.change);\n        formRef.current.removeEventListener(\"focusout\", handlers.blur);\n        formRef.current.removeEventListener(\"submit\", handlers.submit);\n        formRef.current.removeEventListener(\"reset\", handlers.reset);\n        mutationObserverRef.current?.disconnect();\n      }\n\n      shared.remove(id);\n    },\n    [id]\n  );\n\n  return {\n    form: registerForm,\n    field: registerField,\n    focus,\n    removeField,\n    use,\n    getState,\n    setValue,\n    setTouched,\n    setDirty,\n    setError,\n    clearErrors,\n    runValidation,\n    reset,\n    submit,\n  };\n};\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"checkbox\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"radio\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLSelectElement =>\n  field.type === \"select-one\";\n","export default (element: HTMLElement): element is HTMLInputElement =>\n  element.tagName === \"INPUT\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"number\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"range\";\n","import { FieldElement } from \"../types\";\n\nexport default (field: FieldElement): field is HTMLInputElement =>\n  field.type === \"file\";\n","export default (callback: (args: any) => any): any =>\n  (\n    window.requestIdleCallback ||\n    ((cb) => {\n      const start = Date.now();\n      return setTimeout(\n        () =>\n          cb({\n            didTimeout: false,\n            timeRemaining: /* istanbul ignore next */ () =>\n              Math.max(0, 50 - (Date.now() - start)),\n          }),\n        1\n      );\n    })\n  )(callback, { timeout: 2000 });\n","import { FormMethods, FormValues, Methods } from \"./types\";\nimport { get } from \"./shared\";\nimport { invariant } from \"./utils\";\n\nexport default <V extends FormValues = FormValues>(\n  formId?: string\n): FormMethods<V> => {\n  const methods: Methods<V> = get(formId);\n\n  invariant(\n    !methods,\n    'ðŸ’¡ react-cool-form > useFormMethods: It must work with an \"useForm\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form'\n  );\n\n  const {\n    form,\n    field,\n    focus,\n    removeField,\n    use,\n    getState,\n    setValue,\n    setTouched,\n    setDirty,\n    setError,\n    clearErrors,\n    runValidation,\n    reset,\n    submit,\n  } = methods;\n\n  return {\n    form,\n    field,\n    focus,\n    removeField,\n    use,\n    getState,\n    setValue,\n    setTouched,\n    setDirty,\n    setError,\n    clearErrors,\n    runValidation,\n    reset,\n    submit,\n  };\n};\n"],"names":["foo","bar","ctor","len","Date","RegExp","Array","dequal","has","Object","one","all","get","get$1","id","useLatest","val","ref","useRef","arrayToMap","arr","map","obj","key","isObject","value","cloneObject","object","Event","Error","FileList","isPlainObject","deepMerge","objects","prev","prevValue","currValue","filterErrors","error","touched","nextErrors","undefined","stringToPath","str","TypeError","Boolean","path","defaultValue","getIsDirty","dirty","search","dty","found","getPath","isFunction","isAsyncFunction","isEmptyObject","isFieldArray","fields","name","callback","fieldName","isSelectMultiple","field","parseState","state","pathHandler","stateHandler","isGetState","p","paths","s","parsedState","set","immutable","segs","idx","Number","nextIsNumber","newObject","setValuesAsTrue","unset","refObject","target","index","last","t","useState","initialState","onChange","forceUpdate","useReducer","c","stateRef","observersRef","usedState","notify","onChangeRef","useCallback","shouldSkipUpdate","shouldForceUpdate","errors","prevIsDirty","prevIsValid","prevSubmitCount","currSubmitCount","isDirty","isValid","submitCount","fieldPath","k","setStateRef","useFormState","configOrCallback","formId","config","observerRef","methods","o","getFormState","methodName","useControlled","validate","parse","errorWithTouched","shared","isTouched","shouldRemoveField","initialStateRef","fieldArrayRef","fieldValidatorsRef","changedFieldRef","getState","getNodeValue","setDefaultValue","setTouchedMaybeValidate","handleChangeEvent","removeField","isFieldArr","initialVal","props","onBlur","meta","format","e","restProps","useFieldArray","validateOnChange","setNodesOrValues","runValidation","getFields","init","_","setFields","updateFields","shouldSetValues","reset","setState","handler","shouldTouched","shouldDirty","fieldsLength","_state$values$name","f","type","lastIndex","swap","indexA","indexB","move","from","to","push","insert","remove","useForm","validateOnBlur","focusOnError","removeOnUnmounted","builtInValidationMode","onReset","onSubmit","onError","handlersRef","mutationObserverRef","formRef","fieldsRef","Map","fieldParsersRef","controlsRef","formValidatorRef","excludeFieldsRef","excludeFields","onResetRef","onSubmitRef","onErrorRef","hasWarnValues","values","defaultValues","isValidating","isSubmitting","isSubmitted","onStateChange","handleUnset","options","handleFocus","n","_fieldsRef$current$ge2","form","element","fieldId","classList","rcfExclude","exclude","acc","elm","fieldArrayName","_fieldParsersRef$curr","_fieldParsersRef$curr2","checkbox","radio","option","setNodeValue","shouldUpdateDefaultValue","setError","clearErrors","runBuiltInValidation","validity","validationMessage","runAllBuiltInValidation","runFieldValidation","async","exception","runAllFieldsValidation","promises","Promise","cur","runFormValidation","validateField","hasAsyncValidator","validateFieldWithLowPriority","runWithLowPriority","window","cb","start","setTimeout","didTimeout","timeRemaining","Math","timeout","validateForm","errs","shouldFocus","names","dfValues","v","focus","delay","setTouched","shouldValidate","setDirty","setDirtyIfNeeded","setValue","getOptions","submit","skip","nextValues","nextTouched","rest","el","handlersRef.current.change","_fieldParsersRef$curr3","handlersRef.current.blur","handlersRef.current.submit","handlersRef.current.reset","MutationObserver","currOptions","_fieldsRef$current$ge3","_fieldsRef$current$ge4","nextOptions","_fields$get$options","addedNodes","childList","subtree","validator","parsers","set$1","registerForm","registerField","use","handlers","useFormMethods"],"mappings":"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"}