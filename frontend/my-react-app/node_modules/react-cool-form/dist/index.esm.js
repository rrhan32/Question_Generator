import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';
import _extends from '@babel/runtime/helpers/extends';
import { useRef, useReducer, useCallback, useEffect, useState as useState$1 } from 'react';
import { dequal } from 'dequal/lite';

var one;
var all = {};
var get$1 = function get(id) {
  return id ? all[id] : one;
};
var set$1 = function set(id, methods) {
  if (id) {
    all[id] = methods;
  } else {
    one = methods;
  }
};
var remove = function remove(id) {
  if (id) {
    delete all[id];
  } else {
    one = undefined;
  }
};

var useLatest = (function (val) {
  var ref = useRef(val);
  ref.current = val;
  return ref;
});

var arrayToMap = (function (arr, map) {
  if (map === void 0) {
    map = {};
  }

  return arr.reduce(function (obj, key) {
    obj[map[key] || key] = true;
    return obj;
  }, {});
});

var isFileList = (function (value) {
  return value instanceof FileList;
});

var isObject = (function (value) {
  return value !== null && typeof value === "object";
});

var cloneObject = function cloneObject(object) {
  if (object instanceof Event) throw new Error("Unable to clone event.");
  if (!isObject(object) || isFileList(object)) return object;
  if (object instanceof Date) return new Date(object.getTime());
  if (Array.isArray(object)) return object.map(function (val) {
    return cloneObject(val);
  });
  return Object.keys(object).reduce(function (obj, key) {
    obj[key] = cloneObject(object[key]);
    return obj;
  }, {});
};

var compact = (function (arr) {
  return arr.filter(Boolean);
});

var isPlainObject = (function (value) {
  return !Array.isArray(value) && !(value instanceof Date) && isObject(value);
});

var deepMerge = function deepMerge() {
  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
    objects[_key] = arguments[_key];
  }

  return objects.reduce(function (prev, obj) {
    Object.keys(obj).forEach(function (key) {
      var prevValue = prev[key];
      var currValue = obj[key];

      if (Array.isArray(prevValue) && Array.isArray(currValue)) {
        prev[key] = [].concat(prevValue, currValue);
      } else if (isPlainObject(prevValue) && isPlainObject(currValue)) {
        prev[key] = deepMerge(prevValue, currValue);
      } else {
        prev[key] = currValue;
      }
    });
    return prev;
  }, {});
};

var isUndefined = (function (value) {
  return value === undefined;
});

var filterErrors = function filterErrors(error, touched) {
  if (!isPlainObject(error)) return touched ? error : undefined;
  return Object.keys(error).reduce(function (obj, key) {
    var nextErrors = filterErrors(error[key], touched[key] || false);

    if (!isUndefined(nextErrors)) {
      obj[key] = nextErrors;
    } else {
      delete obj[key];
    }

    return obj;
  }, {});
};

var stringToPath = (function (str) {
  if (typeof str !== "string") throw new TypeError("Expected a string.");
  if (!str.length) return [];
  return compact(str.split(/[.[\]]+/));
});

var get = (function (object, path, defaultValue) {
  if (!isPlainObject(object) || !path) return defaultValue;
  var value = stringToPath(path).reduce(function (obj, key) {
    return (obj || {})[key];
  }, object);
  return !isUndefined(value) ? value : defaultValue;
});

var getIsDirty = (function (dirty) {
  var search = function search(dty, found) {
    if (found === void 0) {
      found = [];
    }

    for (var _i = 0, _Object$values = Object.values(dty); _i < _Object$values.length; _i++) {
      var val = _Object$values[_i];

      if (val === true) {
        found.push(val);
        return found;
      }

      if (isObject(val)) search(val, found);
    }

    return found;
  };

  return !!search(dirty).length;
});

var getPath = (function (path) {
  return !["values", "touched", "errors", "isDirty", "dirty", "isValidating", "isValid", "isSubmitting", "isSubmitted", "submitCount"].some(function (key) {
    return path.startsWith(key);
  }) ? "values." + path : path;
});

var invariant = (function (condition, message) {
  if (process.env.NODE_ENV !== "production" && condition) throw new Error(message);
});

var isFunction = (function (value) {
  return typeof value === "function";
});

var isAsyncFunction = (function (value) {
  return isFunction(value) && value.constructor.name === "AsyncFunction";
});

var isCheckboxInput = (function (field) {
  return field.type === "checkbox";
});

var isEmptyObject = (function (value) {
  return isPlainObject(value) && !Object.keys(value).length;
});

var isFieldArray = (function (fields, name, callback) {
  var fieldName;
  Object.keys(fields).some(function (key) {
    if (name.startsWith(key)) {
      fieldName = key;
      if (callback) callback(key);
      return true;
    }

    return false;
  });
  return fieldName;
});

var isFieldElement = (function (element) {
  return /INPUT|TEXTAREA|SELECT/.test(element.tagName);
});

var isFileInput = (function (field) {
  return field.type === "file";
});

var isInputElement = (function (element) {
  return element.tagName === "INPUT";
});

var isNumberInput = (function (field) {
  return field.type === "number";
});

var isRadioInput = (function (field) {
  return field.type === "radio";
});

var isRangeInput = (function (field) {
  return field.type === "range";
});

var isSelectMultiple = (function (field) {
  return field.type === "select-multiple";
});

var isSelectOne = (function (field) {
  return field.type === "select-one";
});

var parseState = (function (path, state, pathHandler, stateHandler, isGetState) {
  if (pathHandler === void 0) {
    pathHandler = getPath;
  }

  if (!path) return isGetState ? state : undefined;
  var parsedState;

  if (Array.isArray(path)) {
    parsedState = path.map(function (p) {
      p = pathHandler(p);
      var value = get(state, p);
      return stateHandler ? stateHandler(p, value) : value;
    });
  } else if (isPlainObject(path)) {
    var paths = path;
    parsedState = Object.keys(paths).reduce(function (s, key) {
      path = pathHandler(paths[key]);
      var value = get(state, path);
      s[key] = stateHandler ? stateHandler(path, value) : value;
      return s;
    }, {});
  } else {
    path = pathHandler(path);
    var value = get(state, path);
    parsedState = stateHandler ? stateHandler(path, value) : value;
  }

  return parsedState;
});

var runWithLowPriority = (function (callback) {
  return (window.requestIdleCallback || function (cb) {
    var start = Date.now();
    return setTimeout(function () {
      return cb({
        didTimeout: false,
        timeRemaining:
        /* istanbul ignore next */
        function timeRemaining() {
          return Math.max(0, 50 - (Date.now() - start));
        }
      });
    }, 1);
  })(callback, {
    timeout: 2000
  });
});

var set = (function (object, path, value, immutable) {
  if (!isPlainObject(object)) throw new TypeError("Expected an object.");
  var newObject = immutable ? cloneObject(object) : object;
  var segs = stringToPath(path);
  segs.slice(0, -1).reduce(function (obj, key, idx) {
    var nextIsNumber = !Number.isNaN(+segs[idx + 1]);
    if (isPlainObject(obj[key]) && !nextIsNumber || Array.isArray(obj[key]) && nextIsNumber) return obj[key];
    obj[key] = nextIsNumber ? [] : {};
    return obj[key];
  }, newObject)[segs[segs.length - 1] || ""] = value;
  return newObject;
});

var setValuesAsTrue = function setValuesAsTrue(object) {
  if (!Array.isArray(object) && !isPlainObject(object)) return true;
  if (Array.isArray(object)) return object.map(function (val) {
    return setValuesAsTrue(val);
  });
  return Object.keys(object).reduce(function (obj, key) {
    obj[key] = setValuesAsTrue(object[key]);
    return obj;
  }, {});
};

var unset = function unset(object, path, immutable) {
  if (!isPlainObject(object)) throw new TypeError("Expected an object.");
  var refObject = immutable ? cloneObject(object) : object;
  var newObject = refObject; // eslint-disable-next-line no-prototype-builtins

  if (newObject.hasOwnProperty(path)) {
    delete newObject[path];
    return refObject;
  }

  var segs = stringToPath(path);
  if (!segs.length) return refObject;
  var last = segs.pop();
  var target = segs.reduce(function (obj, key) {
    return (obj || {})[key];
  }, newObject);

  if (Array.isArray(target)) {
    var index = +last;

    if (index < target.length - 1) {
      delete target[index];
    } else {
      while (index >= 0) {
        // @ts-expect-error
        if (index == last || isUndefined(target[index])) {
          target.splice(index, 1);
          index -= 1;
        } else {
          break;
        }
      }
    }
  } else if (isPlainObject(target)) {
    delete target[last];
  }

  return isEmptyObject(target) || Array.isArray(target) && !target.filter(function (t) {
    return !isUndefined(t);
  }).length ? unset(refObject, segs.join(".")) : refObject;
};

var warn = (function () {
  var _console;

  if (process.env.NODE_ENV !== "production") (_console = console).warn.apply(_console, arguments);
});

var useState = (function (initialState, onChange) {
  var _useReducer = useReducer(function (c) {
    return c + 1;
  }, 0),
      forceUpdate = _useReducer[1];

  var stateRef = useRef(initialState);
  var observersRef = useRef([{
    usedState: {},
    notify: forceUpdate
  }]);
  var onChangeRef = useLatest(onChange || function () {
    return undefined;
  });
  var setStateRef = useCallback(function (path, value, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        fieldPath = _ref.fieldPath,
        shouldSkipUpdate = _ref.shouldSkipUpdate,
        shouldForceUpdate = _ref.shouldForceUpdate;

    var key = path.split(".")[0];

    if (!key) {
      if (!dequal(stateRef.current, value)) {
        stateRef.current = value;
        onChangeRef.current(stateRef.current);
        observersRef.current.forEach(function (_ref2) {
          var usedState = _ref2.usedState,
              notify = _ref2.notify;
          return !isEmptyObject(usedState) && notify(stateRef.current);
        });
      }

      return;
    }

    if (path !== "values" && key === "values" || !dequal(get(stateRef.current, path), value)) {
      var state = set(stateRef.current, path, value, true);
      var errors = state.errors,
          dirty = state.dirty,
          prevIsDirty = state.isDirty,
          prevIsValid = state.isValid,
          prevSubmitCount = state.submitCount;
      var currSubmitCount = state.submitCount;
      var isDirty = key === "dirty" ? getIsDirty(dirty) : prevIsDirty;
      var isValid = key === "errors" ? isEmptyObject(errors) : prevIsValid;
      var submitCount = key === "isSubmitting" && value ? currSubmitCount += 1 : currSubmitCount;
      stateRef.current = _extends({}, state, {
        isDirty: isDirty,
        isValid: isValid,
        submitCount: submitCount
      });
      onChangeRef.current(stateRef.current);
      if (shouldSkipUpdate) return;
      path = fieldPath || path;
      observersRef.current.forEach(function (_ref3) {
        var usedState = _ref3.usedState,
            notify = _ref3.notify;
        return (shouldForceUpdate || Object.keys(usedState).some(function (k) {
          return path.startsWith(k) || k.startsWith(path);
        }) || usedState.isDirty && isDirty !== prevIsDirty || usedState.isValid && isValid !== prevIsValid || usedState.submitCount && submitCount !== prevSubmitCount) && notify(stateRef.current);
      });
    }
  }, [onChangeRef]);
  return {
    stateRef: stateRef,
    setStateRef: setStateRef,
    observersRef: observersRef
  };
});

var _excluded$1 = ["defaultValue"],
    _excluded2$1 = ["validate"];
var useForm = (function (_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      id = _ref.id,
      _ref$defaultValues = _ref.defaultValues,
      defaultValues = _ref$defaultValues === void 0 ? {} : _ref$defaultValues,
      validate = _ref.validate,
      _ref$validateOnChange = _ref.validateOnChange,
      validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange,
      _ref$validateOnBlur = _ref.validateOnBlur,
      validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur,
      _ref$focusOnError = _ref.focusOnError,
      focusOnError = _ref$focusOnError === void 0 ? true : _ref$focusOnError,
      _ref$removeOnUnmounte = _ref.removeOnUnmounted,
      removeOnUnmounted = _ref$removeOnUnmounte === void 0 ? true : _ref$removeOnUnmounte,
      _ref$builtInValidatio = _ref.builtInValidationMode,
      builtInValidationMode = _ref$builtInValidatio === void 0 ? "message" : _ref$builtInValidatio,
      _ref$excludeFields = _ref.excludeFields,
      excludeFields = _ref$excludeFields === void 0 ? [] : _ref$excludeFields,
      onReset = _ref.onReset,
      onSubmit = _ref.onSubmit,
      onError = _ref.onError,
      onStateChange = _ref.onStateChange;

  var handlersRef = useRef({});
  var mutationObserverRef = useRef();
  var formRef = useRef();
  var fieldsRef = useRef(new Map());
  var fieldParsersRef = useRef({});
  var fieldArrayRef = useRef({});
  var controlsRef = useRef({});
  var formValidatorRef = useLatest(validate);
  var fieldValidatorsRef = useRef({});
  var changedFieldRef = useRef();
  var excludeFieldsRef = useRef(arrayToMap(excludeFields));
  var onResetRef = useLatest(onReset || function () {
    return undefined;
  });
  var onSubmitRef = useLatest(onSubmit || function () {
    return undefined;
  });
  var onErrorRef = useLatest(onError || function () {
    return undefined;
  });
  var hasWarnValues = useRef(false);
  var initialStateRef = useRef({
    values: defaultValues,
    touched: {},
    errors: {},
    isDirty: false,
    dirty: {},
    isValidating: false,
    isValid: true,
    isSubmitting: false,
    isSubmitted: false,
    submitCount: 0
  });

  var _useState = useState(_extends({}, initialStateRef.current), onStateChange),
      stateRef = _useState.stateRef,
      setStateRef = _useState.setStateRef,
      observersRef = _useState.observersRef;

  var handleUnset = useCallback(function (path, options) {
    var segs = path.split(".");
    var k = segs.shift();
    setStateRef(k, unset(stateRef.current[k], segs.join("."), true), _extends({
      fieldPath: path
    }, options));
  }, [setStateRef, stateRef]);
  var handleFocus = useCallback(function (name) {
    var _fieldsRef$current$ge, _fieldsRef$current$ge2;

    var field = ((_fieldsRef$current$ge = fieldsRef.current.get(name)) == null ? void 0 : _fieldsRef$current$ge.field) || ((_fieldsRef$current$ge2 = fieldsRef.current.get(Array.from(fieldsRef.current.keys()).find(function (n) {
      return n.startsWith(name);
    }) || "")) == null ? void 0 : _fieldsRef$current$ge2.field);
    if (field && isFunction(field.focus)) field.focus();
  }, []);
  var getFields = useCallback(function (form) {
    return Array.from(form.querySelectorAll("input,textarea,select")).filter(function (element) {
      var field = element;
      var type = field.type,
          name = field.name,
          fieldId = field.id,
          classList = field.classList,
          rcfExclude = field.dataset.rcfExclude;
      var exclude = excludeFieldsRef.current;
      if (/button|image|submit|reset/.test(type) || fieldId && exclude["#" + fieldId] || Array.from(classList).find(function (n) {
        return exclude["." + n];
      })) return false;

      if (rcfExclude !== "true" && !name) {
        warn('ðŸ’¡ react-cool-form > field: Missing "name" attribute. Do you want to exclude the field? See: https://react-cool-form.netlify.app/docs/api-reference/use-form/#excludefields');
        return false;
      }

      return controlsRef.current[name] || rcfExclude !== "true" && !exclude[name];
    }).reduce(function (acc, elm) {
      var _acc$get;

      var field = elm;
      var name = field.name;
      var fieldArrayName = isFieldArray(fieldArrayRef.current, name);
      if (fieldArrayName) fieldArrayRef.current[fieldArrayName].fields[name] = true;
      acc.set(name, _extends({}, acc.get(name), {
        field: ((_acc$get = acc.get(name)) == null ? void 0 : _acc$get.field) || field
      }));

      if (isCheckboxInput(field) || isRadioInput(field)) {
        acc.get(name).options = acc.get(name).options ? [].concat(acc.get(name).options, [field]) : [field];
      } else if (isSelectOne(field) || isSelectMultiple(field)) {
        acc.get(name).options = Array.from(field.options);
      }

      return acc;
    }, new Map());
  }, []);
  var getNodeValue = useCallback(function (name, fields) {
    var _find;

    if (fields === void 0) {
      fields = fieldsRef.current;
    }

    if (!fields.has(name)) return undefined;

    var _ref2 = fields.get(name),
        field = _ref2.field,
        options = _ref2.options;

    if (isInputElement(field)) {
      var _fieldParsersRef$curr, _fieldParsersRef$curr2;

      if ((_fieldParsersRef$curr = fieldParsersRef.current[name]) != null && _fieldParsersRef$curr.valueAsNumber) return field.valueAsNumber;
      if ((_fieldParsersRef$curr2 = fieldParsersRef.current[name]) != null && _fieldParsersRef$curr2.valueAsDate) return field.valueAsDate;
    }

    if (isNumberInput(field) || isRangeInput(field)) return field.valueAsNumber || "";

    if (isCheckboxInput(field)) {
      var checkboxes = options;
      if (checkboxes.length > 1) return checkboxes.filter(function (c) {
        return c.checked;
      }).map(function (c) {
        return c.value;
      });
      var checkbox = checkboxes[0];
      if (checkbox.hasAttribute("value") && checkbox.value) return checkbox.checked ? [checkbox.value] : [];
      return checkbox.checked;
    }

    if (isRadioInput(field)) return ((_find = options.find(function (radio) {
      return radio.checked;
    })) == null ? void 0 : _find.value) || "";
    if (isSelectMultiple(field)) return options.filter(function (option) {
      return option.selected;
    }).map(function (option) {
      return option.value;
    });
    if (isFileInput(field)) return field.files;
    return field.value;
  }, []);
  var setNodeValue = useCallback(function (name, value, fields) {
    if (fields === void 0) {
      fields = fieldsRef.current;
    }

    if (!fields.has(name) || controlsRef.current[name]) return;

    var _ref3 = fields.get(name),
        field = _ref3.field,
        options = _ref3.options;

    if (isCheckboxInput(field)) {
      var checkboxes = options;

      if (checkboxes.length > 1) {
        checkboxes.forEach(function (checkbox) {
          checkbox.checked = Array.isArray(value) ? value.includes(checkbox.value) : !!value;
        });
      } else {
        checkboxes[0].checked = !!value;
      }
    } else if (isRadioInput(field)) {
      options.forEach(function (radio) {
        radio.checked = radio.value === value;
      });
    } else if (isSelectMultiple(field) && Array.isArray(value)) {
      options.forEach(function (option) {
        option.selected = !!value.includes(option.value);
      });
    } else if (isFileInput(field)) {
      if (isFileList(value)) field.files = value;
      if (!value) field.value = "";
    } else {
      field.value = value != null ? value : "";
    }
  }, []);
  var setDefaultValue = useCallback(function (name, value, shouldUpdateDefaultValue) {
    if (shouldUpdateDefaultValue === void 0) {
      shouldUpdateDefaultValue = !isFieldArray(fieldArrayRef.current, name) || !isUndefined(get(initialStateRef.current.values, name.split(".")[0]));
    }

    if (shouldUpdateDefaultValue) initialStateRef.current.values = set(initialStateRef.current.values, name, value, true);
    if (!dequal(get(stateRef.current.values, name), value)) setStateRef("values." + name, value, {
      shouldSkipUpdate: true
    });
  }, [setStateRef, stateRef]);
  var setNodesOrValues = useCallback(function (values, _temp2) {
    var _ref4 = _temp2 === void 0 ? {} : _temp2,
        _ref4$shouldSetValues = _ref4.shouldSetValues,
        shouldSetValues = _ref4$shouldSetValues === void 0 ? true : _ref4$shouldSetValues,
        _ref4$fields = _ref4.fields,
        fields = _ref4$fields === void 0 ? Array.from(fieldsRef.current.keys()) : _ref4$fields;

    return fields.forEach(function (name) {
      if (controlsRef.current[name]) return;
      var value = get(values, name);
      if (!isUndefined(value)) setNodeValue(name, value);
      if (shouldSetValues) setDefaultValue(name, !isUndefined(value) ? value : getNodeValue(name));
    });
  }, [getNodeValue, setDefaultValue, setNodeValue]);
  var setError = useCallback(function (name, error) {
    error = isFunction(error) ? error(get(stateRef.current.errors, name)) : error;

    if (error) {
      setStateRef("errors." + name, error);
    } else {
      handleUnset("errors." + name);
    }
  }, [handleUnset, setStateRef, stateRef]);
  var clearErrors = useCallback(function (name) {
    if (!name) {
      setStateRef("errors", {});
    } else if (Array.isArray(name)) {
      name.forEach(function (n) {
        return setError(n);
      });
    } else {
      setError(name);
    }
  }, [setError, setStateRef]);
  var runBuiltInValidation = useCallback(function (name) {
    if (builtInValidationMode === false || !fieldsRef.current.has(name)) return undefined;

    var _ref5 = fieldsRef.current.get(name),
        _ref5$field = _ref5.field,
        validity = _ref5$field.validity,
        validationMessage = _ref5$field.validationMessage;

    if (builtInValidationMode === "state") for (var k in validity) {
      if (k !== "valid" && validity[k]) return k;
    }
    return validationMessage;
  }, [builtInValidationMode]);
  var runAllBuiltInValidation = useCallback(function () {
    if (builtInValidationMode === false) return {};
    return Array.from(fieldsRef.current.keys()).reduce(function (errors, name) {
      var error = runBuiltInValidation(name);
      errors = _extends({}, errors, error ? set(errors, name, error) : {});
      return errors;
    }, {});
  }, [builtInValidationMode, runBuiltInValidation]);
  var runFieldValidation = useCallback(async function (name) {
    var value = get(stateRef.current.values, name);
    if (!fieldValidatorsRef.current[name] || isUndefined(value)) return undefined;

    try {
      var error = await fieldValidatorsRef.current[name](value, stateRef.current.values);
      return error;
    } catch (exception) {
      warn("\uD83D\uDCA1 react-cool-form > validate " + name + ": ", exception);
      throw exception;
    }
  }, [stateRef]);
  var runAllFieldsValidation = useCallback(function () {
    var promises = Object.keys(fieldValidatorsRef.current).map(function (name) {
      return runFieldValidation(name);
    });
    return Promise.all(promises).then(function (errors) {
      return Object.keys(fieldValidatorsRef.current).reduce(function (acc, cur, idx) {
        acc = _extends({}, acc, errors[idx] ? set(acc, cur, errors[idx]) : {});
        return acc;
      }, {});
    });
  }, [runFieldValidation]);
  var runFormValidation = useCallback(async function (name) {
    if (!formValidatorRef.current) return name ? undefined : {};

    try {
      var errors = await formValidatorRef.current(stateRef.current.values);
      if (name) return get(errors, name);
      return isPlainObject(errors) ? errors : {};
    } catch (exception) {
      warn("\uD83D\uDCA1 react-cool-form > validate form: ", exception);
      throw exception;
    }
  }, [formValidatorRef, stateRef]);
  var validateField = useCallback(async function (name) {
    var hasAsyncValidator = isAsyncFunction(formValidatorRef.current) || isAsyncFunction(fieldValidatorsRef.current[name]);
    if (hasAsyncValidator) setStateRef("isValidating", true);

    try {
      var error = (await runFormValidation(name)) || (await runFieldValidation(name)) || runBuiltInValidation(name);
      setError(name, error);
      if (hasAsyncValidator) setStateRef("isValidating", false);
      return error;
    } catch (exception) {
      return exception;
    }
  }, [formValidatorRef, runBuiltInValidation, runFieldValidation, runFormValidation, setError, setStateRef]);
  var validateFieldWithLowPriority = useCallback(function (name) {
    return runWithLowPriority(function () {
      return validateField(name);
    });
  }, [validateField]);
  var validateForm = useCallback(function () {
    setStateRef("isValidating", true);
    return Promise.all([runAllBuiltInValidation(), runAllFieldsValidation(), runFormValidation()]).then(function (errors) {
      var errs = deepMerge.apply(void 0, errors);
      setStateRef("errors", errs);
      setStateRef("isValidating", false);
      return errs;
    });
  }, [runAllBuiltInValidation, runAllFieldsValidation, runFormValidation, setStateRef]);
  var runValidation = useCallback(function (name, _temp3) {
    var _ref6 = _temp3 === void 0 ? {} : _temp3,
        _ref6$shouldFocus = _ref6.shouldFocus,
        shouldFocus = _ref6$shouldFocus === void 0 ? focusOnError : _ref6$shouldFocus;

    var names = [];

    if (shouldFocus) {
      names = Array.isArray(shouldFocus) ? shouldFocus : Array.from(fieldsRef.current.keys());
      names = isFunction(shouldFocus) ? shouldFocus(names) : names;
    }

    if (!name) return validateForm().then(function (errors) {
      if (shouldFocus) {
        var fieldName = names.find(function (n) {
          return get(errors, n);
        });
        if (fieldName) handleFocus(fieldName);
      }

      return isEmptyObject(errors);
    });
    if (Array.isArray(name)) return Promise.all(name.map(function (n) {
      return validateField(n);
    })).then(function (errors) {
      if (shouldFocus) {
        var fieldName = names.find(function (n) {
          return !!errors[name.indexOf(n)];
        });
        if (fieldName) handleFocus(fieldName);
      }

      return !compact(errors).length;
    });
    return validateField(name).then(function (error) {
      if (shouldFocus && error && names.includes(name)) handleFocus(name);
      return !error;
    });
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [handleFocus, validateField, validateForm]);
  var getFormState = useCallback(function (path, _temp4) {
    var _ref7 = _temp4 === void 0 ? {} : _temp4,
        errorWithTouched = _ref7.errorWithTouched,
        _ref7$defaultValues = _ref7.defaultValues,
        dfValues = _ref7$defaultValues === void 0 ? {} : _ref7$defaultValues,
        _ref7$methodName = _ref7.methodName,
        methodName = _ref7$methodName === void 0 ? "getState" : _ref7$methodName,
        callback = _ref7.callback;

    var usedState = {};
    var state = parseState(path, stateRef.current, function (p) {
      p = getPath(p);

      if (methodName !== "getState") {
        if (p === "values" && methodName !== "useFormStateCallback" && !hasWarnValues.current) {
          warn("\uD83D\uDCA1 react-cool-form > " + methodName + ": Getting \"values\" alone might cause unnecessary re-renders. If you know what you're doing, just ignore this warning. See: https://react-cool-form.netlify.app/docs/getting-started/form-state#best-practices");
          hasWarnValues.current = true;
        }

        usedState[p] = true;
      }

      return p;
    }, function (p, v) {
      if (methodName === "getState") return v;

      if (p.startsWith("values")) {
        if (!isUndefined(v)) return v;
        p = p.replace("values.", "");
        v = get(initialStateRef.current, p);
        return !isUndefined(v) ? v : get(dfValues, p);
      }

      if (!errorWithTouched || !p.startsWith("errors")) return v;
      p = p.replace("errors", "touched");
      usedState[p] = true;
      return filterErrors(v, get(stateRef.current, p));
    }, methodName === "getState");
    if (callback) callback(usedState);
    return state;
  }, [stateRef]);
  var focus = useCallback(function (name, delay) {
    if (!isUndefined(delay)) {
      setTimeout(function () {
        return handleFocus(name);
      }, delay);
    } else {
      handleFocus(name);
    }
  }, [handleFocus]);
  var use = useCallback(function (path, _temp5) {
    var _ref8 = _temp5 === void 0 ? {} : _temp5,
        errorWithTouched = _ref8.errorWithTouched,
        dfValues = _ref8.defaultValues;

    return getFormState(path, {
      errorWithTouched: errorWithTouched,
      defaultValues: dfValues,
      methodName: "use",
      callback: function callback(usedState) {
        observersRef.current[0].usedState = _extends({}, observersRef.current[0].usedState, usedState);
      }
    });
  }, [getFormState, observersRef]);
  var getState = useCallback(function (path) {
    return getFormState(path);
  }, [getFormState]);
  var setTouched = useCallback(function (name, isTouched, _temp6) {
    if (isTouched === void 0) {
      isTouched = true;
    }

    var _ref9 = _temp6 === void 0 ? {} : _temp6,
        _ref9$shouldValidate = _ref9.shouldValidate,
        shouldValidate = _ref9$shouldValidate === void 0 ? validateOnBlur : _ref9$shouldValidate;

    if (isTouched) {
      setStateRef("touched." + name, true);
    } else {
      handleUnset("touched." + name);
    }

    if (shouldValidate) validateFieldWithLowPriority(name);
  }, [handleUnset, setStateRef, validateFieldWithLowPriority, validateOnBlur]);
  var setTouchedMaybeValidate = useCallback(function (name) {
    return setTouched(name, true, {
      shouldValidate: validateOnChange ? name !== changedFieldRef.current : undefined
    });
  }, [setTouched, validateOnChange]);
  var setDirty = useCallback(function (name, isDirty) {
    if (isDirty === void 0) {
      isDirty = true;
    }

    if (isDirty) {
      setStateRef("dirty." + name, true);
    } else {
      handleUnset("dirty." + name);
    }
  }, [handleUnset, setStateRef]);
  var setDirtyIfNeeded = useCallback(function (name) {
    return setDirty(name, !dequal(get(stateRef.current.values, name), get(initialStateRef.current.values, name)));
  }, [setDirty, stateRef]);
  var setValue = useCallback(function (name, value, _temp7) {
    var _ref10 = _temp7 === void 0 ? {} : _temp7,
        _ref10$shouldValidate = _ref10.shouldValidate,
        shouldValidate = _ref10$shouldValidate === void 0 ? validateOnChange : _ref10$shouldValidate,
        _ref10$shouldTouched = _ref10.shouldTouched,
        shouldTouched = _ref10$shouldTouched === void 0 ? true : _ref10$shouldTouched,
        _ref10$shouldDirty = _ref10.shouldDirty,
        shouldDirty = _ref10$shouldDirty === void 0 ? true : _ref10$shouldDirty;

    value = isFunction(value) ? value(get(stateRef.current.values, name)) : value;

    if (!isUndefined(value)) {
      setStateRef("values." + name, value);
    } else {
      handleUnset("values." + name);
    }

    setNodeValue(name, value);
    isFieldArray(fieldArrayRef.current, name, function (key) {
      return fieldArrayRef.current[key].reset();
    });
    if (shouldTouched) setTouched(name, true, {
      shouldValidate: false
    });
    if (shouldDirty) setDirtyIfNeeded(name);
    if (shouldValidate) validateFieldWithLowPriority(name);
  }, [handleUnset, setDirtyIfNeeded, setNodeValue, setStateRef, setTouched, stateRef, validateFieldWithLowPriority, validateOnChange]);
  var getOptions = useCallback(function () {
    return {
      getState: getState,
      setValue: setValue,
      setTouched: setTouched,
      setDirty: setDirty,
      setError: setError,
      clearErrors: clearErrors,
      runValidation: runValidation,
      removeField: removeField,
      focus: focus,
      reset: reset,
      submit: submit
    };
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  var reset = useCallback(function (values, exclude, e) {
    if (e != null && e.preventDefault) e.preventDefault();
    if (e != null && e.stopPropagation) e.stopPropagation();

    var state = _extends({}, stateRef.current);

    var skip = arrayToMap(exclude || []);
    Object.keys(state).forEach(function (key) {
      if (skip[key]) return;

      if (key === "values") {
        var nextValues = (isFunction(values) ? values(stateRef.current.values) : values) || initialStateRef.current.values;
        state[key] = nextValues;
        initialStateRef.current.values = nextValues;
        setNodesOrValues(nextValues, {
          shouldSetValues: false,
          fields: Array.from(fieldsRef.current.keys()).filter(function (name) {
            return !isFieldArray(fieldArrayRef.current, name);
          })
        });
      } else {
        // @ts-expect-error
        state[key] = initialStateRef.current[key];
      }
    });
    setStateRef("", state);
    onResetRef.current(state.values, getOptions(), e);
    Object.values(fieldArrayRef.current).forEach(function (field) {
      return field.reset();
    });
  }, [getOptions, onResetRef, setNodesOrValues, setStateRef, stateRef]);
  var submit = useCallback(async function (e) {
    if (e != null && e.preventDefault) e.preventDefault();
    if (e != null && e.stopPropagation) e.stopPropagation();
    var nextTouched = [].concat(Array.from(fieldsRef.current.keys()), Object.keys(controlsRef.current)).reduce(function (touched, name) {
      touched = set(touched, name, true, true);
      return touched;
    }, stateRef.current.touched);
    setStateRef("touched", nextTouched);
    setStateRef("isSubmitted", false);
    setStateRef("isSubmitting", true);

    try {
      var isValid = await runValidation();

      if (!isValid) {
        var errors = stateRef.current.errors;
        onErrorRef.current(errors, getOptions(), e);
        return {
          errors: errors
        };
      }

      await onSubmitRef.current(stateRef.current.values, getOptions(), e);
      setStateRef("isSubmitted", true);
      return {
        values: stateRef.current.values
      };
    } catch (exception) {
      warn("\uD83D\uDCA1 react-cool-form > submit: ", exception);
      throw exception;
    } finally {
      setStateRef("isSubmitting", false);
    }
  }, [getOptions, onErrorRef, onSubmitRef, runValidation, setStateRef, stateRef]);
  var handleChangeEvent = useCallback(function (name, value) {
    setStateRef("values." + name, value);
    setDirtyIfNeeded(name);
    if (validateOnChange) validateFieldWithLowPriority(name);
  }, [setDirtyIfNeeded, setStateRef, validateFieldWithLowPriority, validateOnChange]);
  var shouldRemoveField = useCallback(function (name) {
    if (!removeOnUnmounted) return false;
    var names = Array.isArray(removeOnUnmounted) ? removeOnUnmounted : [].concat(Array.from(fieldsRef.current.keys()), Object.keys(controlsRef.current), Object.keys(fieldArrayRef.current));
    names = isFunction(removeOnUnmounted) ? removeOnUnmounted(names) : names;
    return names.includes(name);
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  var removeField = useCallback(function (name, exclude) {
    var _arrayToMap = arrayToMap(exclude || [], {
      value: "values",
      error: "errors"
    }),
        defaultValue = _arrayToMap.defaultValue,
        rest = _objectWithoutPropertiesLoose(_arrayToMap, _excluded$1);

    if (!defaultValue) initialStateRef.current.values = unset(initialStateRef.current.values, name, true);
    ["values", "touched", "dirty", "errors"].forEach(function (key, idx, arr) {
      var shouldForceUpdate = idx === arr.length - 1;
      if (!rest[key] && !isUndefined(get(stateRef.current[key], name))) handleUnset(key + "." + name, {
        shouldSkipUpdate: !shouldForceUpdate,
        shouldForceUpdate: shouldForceUpdate
      });
    });
    delete fieldParsersRef.current[name];
    delete fieldValidatorsRef.current[name];
    delete fieldArrayRef.current[name];
    delete controlsRef.current[name];
    if (fieldsRef.current.has(name)) fieldsRef.current["delete"](name);
  }, [handleUnset, stateRef]);
  var registerForm = useCallback(function (el) {
    if (!el) return;
    formRef.current = el;
    var form = formRef.current;
    fieldsRef.current = getFields(form);
    setNodesOrValues(initialStateRef.current.values);

    handlersRef.current.change = function (_ref11) {
      var target = _ref11.target;
      var _ref12 = target,
          name = _ref12.name;

      if (fieldsRef.current.has(name) && !controlsRef.current[name]) {
        var _fieldParsersRef$curr3;

        var parse = (_fieldParsersRef$curr3 = fieldParsersRef.current[name]) == null ? void 0 : _fieldParsersRef$curr3.parse;
        var value = getNodeValue(name);
        handleChangeEvent(name, parse ? parse(value) : value);
        changedFieldRef.current = name;
      }
    };

    handlersRef.current.blur = function (_ref13) {
      var target = _ref13.target;
      if (!isFieldElement(target)) return;
      var _ref14 = target,
          name = _ref14.name;

      if (fieldsRef.current.has(name) && !controlsRef.current[name]) {
        setTouchedMaybeValidate(name);
        changedFieldRef.current = undefined;
      }
    };

    handlersRef.current.submit = function (e) {
      return submit(e);
    };

    handlersRef.current.reset = function (e) {
      return reset(null, null, e);
    };

    form.addEventListener("input", handlersRef.current.change);
    form.addEventListener("focusout", handlersRef.current.blur);
    form.addEventListener("submit", handlersRef.current.submit);
    form.addEventListener("reset", handlersRef.current.reset);
    mutationObserverRef.current = new MutationObserver(function (_ref15) {
      var type = _ref15[0].type;
      if (type !== "childList") return;
      var fields = getFields(form);
      var values = initialStateRef.current.values;
      fieldsRef.current.forEach(function (_, name) {
        var _fieldsRef$current$ge3, _fieldsRef$current$ge4, _fields$get$options;

        if (!shouldRemoveField(name)) return;
        if (controlsRef.current[name]) return;

        if (!fields.has(name)) {
          removeField(name, !isFieldArray(fieldArrayRef.current, name) || isUndefined(get(initialStateRef.current.values, name.split(".")[0])) ? undefined : ["defaultValue"]);
          return;
        }

        var currOptions = (_fieldsRef$current$ge3 = fieldsRef.current.get(name)) == null ? void 0 : (_fieldsRef$current$ge4 = _fieldsRef$current$ge3.options) == null ? void 0 : _fieldsRef$current$ge4.length;
        var nextOptions = (_fields$get$options = fields.get(name).options) == null ? void 0 : _fields$get$options.length;

        if (currOptions > nextOptions) {
          setStateRef("values." + name, getNodeValue(name, fields), {
            shouldSkipUpdate: true
          });
        } else if (currOptions < nextOptions) {
          setNodeValue(name, get(values, name), fields);
        }
      });
      var addedNodes = [];
      fields.forEach(function (_, name) {
        if (fieldsRef.current.has(name) || controlsRef.current[name]) return;
        var value = get(stateRef.current.values, name);
        if (!isUndefined(value)) values = set(values, name, value, true);
        addedNodes.push(name);
      });
      fieldsRef.current = fields;
      if (addedNodes.length) setNodesOrValues(values, {
        fields: addedNodes
      });
    });
    mutationObserverRef.current.observe(form, {
      childList: true,
      subtree: true
    });
  }, [getFields, getNodeValue, handleChangeEvent, removeField, reset, setNodeValue, setNodesOrValues, setStateRef, setTouchedMaybeValidate, shouldRemoveField, stateRef, submit]);
  var registerField = useCallback(function (value) {
    return function (field) {
      if (!(field != null && field.name) || controlsRef.current[field.name] || excludeFieldsRef.current[field.name]) return;

      if (isFunction(value)) {
        fieldValidatorsRef.current[field.name] = value;
        return;
      }

      var validator = value.validate,
          parsers = _objectWithoutPropertiesLoose(value, _excluded2$1);

      if (validator) fieldValidatorsRef.current[field.name] = validator;
      fieldParsersRef.current[field.name] = parsers;
    };
  }, []);
  set$1(id, {
    validateOnChange: validateOnChange,
    shouldRemoveField: shouldRemoveField,
    initialStateRef: initialStateRef,
    fieldArrayRef: fieldArrayRef,
    controlsRef: controlsRef,
    observersRef: observersRef,
    fieldValidatorsRef: fieldValidatorsRef,
    changedFieldRef: changedFieldRef,
    setStateRef: setStateRef,
    getNodeValue: getNodeValue,
    getFormState: getFormState,
    setDefaultValue: setDefaultValue,
    setNodesOrValues: setNodesOrValues,
    setTouchedMaybeValidate: setTouchedMaybeValidate,
    handleChangeEvent: handleChangeEvent,
    removeField: removeField,
    form: registerForm,
    field: registerField,
    focus: focus,
    use: use,
    getState: getState,
    setValue: setValue,
    setTouched: setTouched,
    setDirty: setDirty,
    setError: setError,
    clearErrors: clearErrors,
    runValidation: runValidation,
    reset: reset,
    submit: submit
  });
  useEffect(function () {
    return function () {
      if (formRef.current) {
        var _mutationObserverRef$;

        var handlers = handlersRef.current;
        formRef.current.removeEventListener("input", handlers.change);
        formRef.current.removeEventListener("focusout", handlers.blur);
        formRef.current.removeEventListener("submit", handlers.submit);
        formRef.current.removeEventListener("reset", handlers.reset);
        (_mutationObserverRef$ = mutationObserverRef.current) == null ? void 0 : _mutationObserverRef$.disconnect();
      }

      remove(id);
    };
  }, [id]);
  return {
    form: registerForm,
    field: registerField,
    focus: focus,
    removeField: removeField,
    use: use,
    getState: getState,
    setValue: setValue,
    setTouched: setTouched,
    setDirty: setDirty,
    setError: setError,
    clearErrors: clearErrors,
    runValidation: runValidation,
    reset: reset,
    submit: submit
  };
});

var useFormMethods = (function (formId) {
  var methods = get$1(formId);
  invariant(!methods, 'ðŸ’¡ react-cool-form > useFormMethods: It must work with an "useForm" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form');
  var form = methods.form,
      field = methods.field,
      focus = methods.focus,
      removeField = methods.removeField,
      use = methods.use,
      getState = methods.getState,
      setValue = methods.setValue,
      setTouched = methods.setTouched,
      setDirty = methods.setDirty,
      setError = methods.setError,
      clearErrors = methods.clearErrors,
      runValidation = methods.runValidation,
      reset = methods.reset,
      submit = methods.submit;
  return {
    form: form,
    field: field,
    focus: focus,
    removeField: removeField,
    use: use,
    getState: getState,
    setValue: setValue,
    setTouched: setTouched,
    setDirty: setDirty,
    setError: setError,
    clearErrors: clearErrors,
    runValidation: runValidation,
    reset: reset,
    submit: submit
  };
});

var useFormState = (function (path, configOrCallback, formId) {
  var config = !isFunction(configOrCallback) ? configOrCallback : {};
  var methods = get$1((config == null ? void 0 : config.formId) || formId);
  invariant(!methods, "\uD83D\uDCA1 react-cool-form > useFormState: It must work with an \"useForm\" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form");
  var observerRef = useRef();

  var _useReducer = useReducer(function (c) {
    return c + 1;
  }, 0),
      forceUpdate = _useReducer[1];

  var observersRef = methods.observersRef,
      getFormState = methods.getFormState;

  var _callback = isFunction(configOrCallback) ? configOrCallback : undefined;

  useEffect(function () {
    observersRef.current.push(observerRef.current);
    return function () {
      observersRef.current = observersRef.current.filter(function (o) {
        return o !== observerRef.current;
      });
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  return getFormState(path, _extends({}, config, {
    methodName: _callback ? "useFormStateCallback" : "useFormState",
    callback: function callback(usedState) {
      if (!observerRef.current) observerRef.current = {
        usedState: usedState,
        notify: _callback ? function (state) {
          return _callback(parseState(path, state));
        } : forceUpdate
      };
    }
  }));
});

var _excluded = ["formId", "defaultValue", "validate", "parse", "format", "errorWithTouched"],
    _excluded2 = ["onChange", "onBlur"];
var useControlled = (function (name, _temp) {
  var _ref2;

  var _ref = _temp === void 0 ? {} : _temp,
      formId = _ref.formId,
      defaultValue = _ref.defaultValue,
      validate = _ref.validate,
      parse = _ref.parse,
      format = _ref.format,
      errorWithTouched = _ref.errorWithTouched,
      props = _objectWithoutPropertiesLoose(_ref, _excluded);

  var methods = get$1(formId);
  invariant(!methods, 'ðŸ’¡ react-cool-form > useControlled: It must work with an "useForm" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form');
  var meta = useFormState({
    value: "values." + name,
    error: "errors." + name,
    isTouched: "touched." + name,
    isDirty: "dirty." + name
  }, {
    formId: formId,
    errorWithTouched: errorWithTouched
  });
  var shouldRemoveField = methods.shouldRemoveField,
      initialStateRef = methods.initialStateRef,
      fieldArrayRef = methods.fieldArrayRef,
      controlsRef = methods.controlsRef,
      fieldValidatorsRef = methods.fieldValidatorsRef,
      changedFieldRef = methods.changedFieldRef,
      getState = methods.getState,
      getNodeValue = methods.getNodeValue,
      setDefaultValue = methods.setDefaultValue,
      setTouchedMaybeValidate = methods.setTouchedMaybeValidate,
      handleChangeEvent = methods.handleChangeEvent,
      removeField = methods.removeField;
  useEffect(function () {
    var isFieldArr = isFieldArray(fieldArrayRef.current, name);
    var initialVal = get(initialStateRef.current.values, name);

    if (isUndefined(initialVal)) {
      if (!isUndefined(defaultValue) && (!isFieldArr || !isUndefined(get(initialStateRef.current.values, name.split(".")[0])))) {
        setDefaultValue(name, defaultValue);
      } else if (!isFieldArr) {
        warn("\uD83D\uDCA1 react-cool-form > useControlled: Please provide a default value for \"" + name + "\" field.");
      }
    } else if (isUndefined(getState(name))) {
      setDefaultValue(name, initialVal);
    }

    return function () {
      if (shouldRemoveField(name)) removeField(name, !isFieldArr || isUndefined( // eslint-disable-next-line react-hooks/exhaustive-deps
      get(initialStateRef.current.values, name.split(".")[0])) ? undefined : ["defaultValue"]);
    };
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  controlsRef.current[name] = true;
  if (validate) fieldValidatorsRef.current[name] = validate;

  var _onChange = props.onChange,
      _onBlur = props.onBlur,
      restProps = _objectWithoutPropertiesLoose(props, _excluded2);

  var value = get(initialStateRef.current.values, name);
  value = !isUndefined(value) ? value : defaultValue;
  value = !isUndefined(meta.value) ? meta.value : value;
  value = (_ref2 = format ? format(value) : value) != null ? _ref2 : "";
  return [_extends({
    name: name,
    value: value,
    onChange: function onChange() {
      var val;

      if (parse) {
        val = parse.apply(void 0, arguments);
      } else {
        var e = arguments.length <= 0 ? undefined : arguments[0];
        val = (e == null ? void 0 : e.nativeEvent) instanceof Event && isFieldElement(e.target) ? getNodeValue(name) : e;
      }

      handleChangeEvent(name, val);
      if (_onChange) _onChange.apply(void 0, arguments);
      changedFieldRef.current = name;
    },
    onBlur: function onBlur(e) {
      setTouchedMaybeValidate(name);
      if (_onBlur) _onBlur(e);
      changedFieldRef.current = undefined;
    }
  }, restProps), {
    error: meta.error,
    isTouched: !!meta.isTouched,
    isDirty: !!meta.isDirty
  }];
});

var useFieldArray = (function (name, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      formId = _ref.formId,
      defaultValue = _ref.defaultValue,
      validate = _ref.validate;

  var methods = get$1(formId);
  invariant(!methods, 'ðŸ’¡ react-cool-form > useFieldArray: It must work with an "useForm" hook. See: https://react-cool-form.netlify.app/docs/api-reference/use-form');
  var validateOnChange = methods.validateOnChange,
      shouldRemoveField = methods.shouldRemoveField,
      initialStateRef = methods.initialStateRef,
      fieldArrayRef = methods.fieldArrayRef,
      fieldValidatorsRef = methods.fieldValidatorsRef,
      getState = methods.getState,
      setDefaultValue = methods.setDefaultValue,
      setNodesOrValues = methods.setNodesOrValues,
      setStateRef = methods.setStateRef,
      runValidation = methods.runValidation,
      removeField = methods.removeField;
  var getFields = useCallback(function (init) {
    if (init === void 0) {
      init = false;
    }

    var fields = getState(name);
    if (init && isUndefined(fields)) fields = defaultValue;
    return Array.isArray(fields) ? fields.map(function (_, index) {
      return name + "[" + index + "]";
    }) : [];
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [getState, name]);

  var _useState = useState$1(getFields(true)),
      fields = _useState[0],
      setFields = _useState[1];

  var updateFields = useCallback(function () {
    setFields(getFields());
    setNodesOrValues(getState("values"), {
      shouldSetValues: false,
      fields: Object.keys(fieldArrayRef.current[name].fields)
    });
  }, [fieldArrayRef, getFields, getState, name, setNodesOrValues]);
  useEffect(function () {
    if (isUndefined(get(initialStateRef.current.values, name)) && !isUndefined(defaultValue)) {
      setDefaultValue(name, defaultValue, true);
      updateFields();
    }

    return function () {
      if (shouldRemoveField(name)) removeField(name);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  if (!fieldArrayRef.current[name]) fieldArrayRef.current[name] = {
    reset: updateFields,
    fields: {}
  };
  if (validate) fieldValidatorsRef.current[name] = validate;
  var setState = useCallback(function (handler, _temp2) {
    var _ref2 = _temp2 === void 0 ? {} : _temp2,
        shouldTouched = _ref2.shouldTouched,
        shouldDirty = _ref2.shouldDirty;

    var state = getState();
    ["values", "touched", "errors", "dirty"].forEach(function (key) {
      var _state$values$name, _extends2;

      var value = state[key][name];
      var fieldsLength = (_state$values$name = state.values[name]) == null ? void 0 : _state$values$name.length;
      if (key === "values" || key === "touched" && shouldTouched || key === "dirty" && shouldDirty || !isUndefined(value)) state = set(state, key, _extends({}, state[key], (_extends2 = {}, _extends2[name] = handler(Array.isArray(value) ? [].concat(value) : [], key, fieldsLength ? fieldsLength - 1 : 0), _extends2)), true);
    });
    setStateRef("", _extends({}, state, {
      shouldDirty: getIsDirty(state.dirty)
    }));
    updateFields();
    if (validateOnChange) runValidation(name);
  }, [getState, name, runValidation, setStateRef, updateFields, validateOnChange]);
  var push = useCallback(function (value, _temp3) {
    var _ref3 = _temp3 === void 0 ? {} : _temp3,
        shouldTouched = _ref3.shouldTouched,
        _ref3$shouldDirty = _ref3.shouldDirty,
        shouldDirty = _ref3$shouldDirty === void 0 ? true : _ref3$shouldDirty;

    var handler = function handler(f, type, lastIndex) {
      if (lastIndex === void 0) {
        lastIndex = 0;
      }

      if (type === "values") {
        f.push(value);
      } else if (type === "touched" && shouldTouched || type === "dirty" && shouldDirty) {
        f[lastIndex] = setValuesAsTrue(value);
      }

      return f;
    };

    setState(handler, {
      shouldTouched: shouldTouched,
      shouldDirty: shouldDirty
    });
  }, [setState]);
  var insert = useCallback(function (index, value, _temp4) {
    var _ref4 = _temp4 === void 0 ? {} : _temp4,
        shouldTouched = _ref4.shouldTouched,
        _ref4$shouldDirty = _ref4.shouldDirty,
        shouldDirty = _ref4$shouldDirty === void 0 ? true : _ref4$shouldDirty;

    var handler = function handler(f, type) {
      if (type === "values") {
        f.splice(index, 0, value);
      } else if (type === "touched" && shouldTouched || type === "dirty" && shouldDirty) {
        f[index] = setValuesAsTrue(value);
      } else if (index < f.length) {
        f.splice(index, 0, undefined);
      }

      return f;
    };

    setState(handler, {
      shouldTouched: shouldTouched,
      shouldDirty: shouldDirty
    });
  }, [setState]);
  var remove = useCallback(function (index) {
    var handler = function handler(f) {
      f.splice(index, 1);
      return compact(f).length ? f : [];
    };

    var value = (getState(name) || [])[index];
    setState(handler);
    return value;
  }, [getState, name, setState]);
  var swap = useCallback(function (indexA, indexB) {
    var handler = function handler(f) {
      var _ref5 = [f[indexB], f[indexA]];
      f[indexA] = _ref5[0];
      f[indexB] = _ref5[1];
      return f;
    };

    setState(handler);
  }, [setState]);
  var move = useCallback(function (from, to) {
    var handler = function handler(f) {
      f.splice(to, 0, f.splice(from, 1)[0]);
      return f;
    };

    setState(handler);
  }, [setState]);
  return [fields, {
    push: push,
    insert: insert,
    remove: remove,
    swap: swap,
    move: move
  }];
});

export { get, set, unset, useControlled, useFieldArray, useForm, useFormMethods, useFormState };
//# sourceMappingURL=index.esm.js.map
